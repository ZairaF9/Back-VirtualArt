
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model categorias
 * 
 */
export type categorias = {
  idcategorias: number
  nombre: string
  imagen: Buffer | null
}

/**
 * Model comentarios
 * 
 */
export type comentarios = {
  idcomentarios: number
  descripcion: string
  fecha: Date
  idusuario: number
  idpublicacion: number
}

/**
 * Model imagen
 * 
 */
export type imagen = {
  idimagen: number
  imagen: Buffer
  idpublicacion: number
}

/**
 * Model publicaciones
 * 
 */
export type publicaciones = {
  idpublicaciones: number
  titulo: string
  descripcion: string
  idcategoria: number
  idusuario: number
}

/**
 * Model publicacionesguardadas
 * 
 */
export type publicacionesguardadas = {
  idpublicacionesguardadas: number
  idpublicacion: number
  idusuario: number
}

/**
 * Model publicacionestablero
 * 
 */
export type publicacionestablero = {
  idpublicacionestablero: number
  idtablero: number
  idpublicacion: number
}

/**
 * Model tablero
 * 
 */
export type tablero = {
  idtablero: number
  nombre: string
  privacidad: number
  idusuario: number
  imagen: Buffer | null
}

/**
 * Model usuario
 * 
 */
export type usuario = {
  idusuario: number
  username: string
  email: string
  userpassword: string | null
  fotoperfil: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categorias
 * const categorias = await prisma.categorias.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categorias
   * const categorias = await prisma.categorias.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.categorias`: Exposes CRUD operations for the **categorias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categorias.findMany()
    * ```
    */
  get categorias(): Prisma.categoriasDelegate<GlobalReject>;

  /**
   * `prisma.comentarios`: Exposes CRUD operations for the **comentarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentarios.findMany()
    * ```
    */
  get comentarios(): Prisma.comentariosDelegate<GlobalReject>;

  /**
   * `prisma.imagen`: Exposes CRUD operations for the **imagen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Imagens
    * const imagens = await prisma.imagen.findMany()
    * ```
    */
  get imagen(): Prisma.imagenDelegate<GlobalReject>;

  /**
   * `prisma.publicaciones`: Exposes CRUD operations for the **publicaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publicaciones
    * const publicaciones = await prisma.publicaciones.findMany()
    * ```
    */
  get publicaciones(): Prisma.publicacionesDelegate<GlobalReject>;

  /**
   * `prisma.publicacionesguardadas`: Exposes CRUD operations for the **publicacionesguardadas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publicacionesguardadas
    * const publicacionesguardadas = await prisma.publicacionesguardadas.findMany()
    * ```
    */
  get publicacionesguardadas(): Prisma.publicacionesguardadasDelegate<GlobalReject>;

  /**
   * `prisma.publicacionestablero`: Exposes CRUD operations for the **publicacionestablero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publicacionestableros
    * const publicacionestableros = await prisma.publicacionestablero.findMany()
    * ```
    */
  get publicacionestablero(): Prisma.publicacionestableroDelegate<GlobalReject>;

  /**
   * `prisma.tablero`: Exposes CRUD operations for the **tablero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tableros
    * const tableros = await prisma.tablero.findMany()
    * ```
    */
  get tablero(): Prisma.tableroDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    categorias: 'categorias',
    comentarios: 'comentarios',
    imagen: 'imagen',
    publicaciones: 'publicaciones',
    publicacionesguardadas: 'publicacionesguardadas',
    publicacionestablero: 'publicacionestablero',
    tablero: 'tablero',
    usuario: 'usuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriasCountOutputType
   */


  export type CategoriasCountOutputType = {
    publicaciones: number
  }

  export type CategoriasCountOutputTypeSelect = {
    publicaciones?: boolean
  }

  export type CategoriasCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoriasCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoriasCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoriasCountOutputTypeArgs)
    ? CategoriasCountOutputType 
    : S extends { select: any } & (CategoriasCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoriasCountOutputType ? CategoriasCountOutputType[P] : never
  } 
      : CategoriasCountOutputType




  // Custom InputTypes

  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoriasCountOutputType
     */
    select?: CategoriasCountOutputTypeSelect | null
  }



  /**
   * Count Type PublicacionesCountOutputType
   */


  export type PublicacionesCountOutputType = {
    comentarios: number
    imagen: number
    publicacionesguardadas: number
    publicacionestablero: number
  }

  export type PublicacionesCountOutputTypeSelect = {
    comentarios?: boolean
    imagen?: boolean
    publicacionesguardadas?: boolean
    publicacionestablero?: boolean
  }

  export type PublicacionesCountOutputTypeGetPayload<S extends boolean | null | undefined | PublicacionesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PublicacionesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PublicacionesCountOutputTypeArgs)
    ? PublicacionesCountOutputType 
    : S extends { select: any } & (PublicacionesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PublicacionesCountOutputType ? PublicacionesCountOutputType[P] : never
  } 
      : PublicacionesCountOutputType




  // Custom InputTypes

  /**
   * PublicacionesCountOutputType without action
   */
  export type PublicacionesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PublicacionesCountOutputType
     */
    select?: PublicacionesCountOutputTypeSelect | null
  }



  /**
   * Count Type TableroCountOutputType
   */


  export type TableroCountOutputType = {
    publicacionestablero: number
  }

  export type TableroCountOutputTypeSelect = {
    publicacionestablero?: boolean
  }

  export type TableroCountOutputTypeGetPayload<S extends boolean | null | undefined | TableroCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TableroCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TableroCountOutputTypeArgs)
    ? TableroCountOutputType 
    : S extends { select: any } & (TableroCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TableroCountOutputType ? TableroCountOutputType[P] : never
  } 
      : TableroCountOutputType




  // Custom InputTypes

  /**
   * TableroCountOutputType without action
   */
  export type TableroCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TableroCountOutputType
     */
    select?: TableroCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    comentarios: number
    publicaciones: number
    publicacionesguardadas: number
    tablero: number
  }

  export type UsuarioCountOutputTypeSelect = {
    comentarios?: boolean
    publicaciones?: boolean
    publicacionesguardadas?: boolean
    tablero?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<S extends boolean | null | undefined | UsuarioCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsuarioCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsuarioCountOutputTypeArgs)
    ? UsuarioCountOutputType 
    : S extends { select: any } & (UsuarioCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
      : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model categorias
   */


  export type AggregateCategorias = {
    _count: CategoriasCountAggregateOutputType | null
    _avg: CategoriasAvgAggregateOutputType | null
    _sum: CategoriasSumAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  export type CategoriasAvgAggregateOutputType = {
    idcategorias: number | null
  }

  export type CategoriasSumAggregateOutputType = {
    idcategorias: number | null
  }

  export type CategoriasMinAggregateOutputType = {
    idcategorias: number | null
    nombre: string | null
    imagen: Buffer | null
  }

  export type CategoriasMaxAggregateOutputType = {
    idcategorias: number | null
    nombre: string | null
    imagen: Buffer | null
  }

  export type CategoriasCountAggregateOutputType = {
    idcategorias: number
    nombre: number
    imagen: number
    _all: number
  }


  export type CategoriasAvgAggregateInputType = {
    idcategorias?: true
  }

  export type CategoriasSumAggregateInputType = {
    idcategorias?: true
  }

  export type CategoriasMinAggregateInputType = {
    idcategorias?: true
    nombre?: true
    imagen?: true
  }

  export type CategoriasMaxAggregateInputType = {
    idcategorias?: true
    nombre?: true
    imagen?: true
  }

  export type CategoriasCountAggregateInputType = {
    idcategorias?: true
    nombre?: true
    imagen?: true
    _all?: true
  }

  export type CategoriasAggregateArgs = {
    /**
     * Filter which categorias to aggregate.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: Enumerable<categoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasMaxAggregateInputType
  }

  export type GetCategoriasAggregateType<T extends CategoriasAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorias[P]>
      : GetScalarType<T[P], AggregateCategorias[P]>
  }




  export type CategoriasGroupByArgs = {
    where?: categoriasWhereInput
    orderBy?: Enumerable<categoriasOrderByWithAggregationInput>
    by: CategoriasScalarFieldEnum[]
    having?: categoriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCountAggregateInputType | true
    _avg?: CategoriasAvgAggregateInputType
    _sum?: CategoriasSumAggregateInputType
    _min?: CategoriasMinAggregateInputType
    _max?: CategoriasMaxAggregateInputType
  }


  export type CategoriasGroupByOutputType = {
    idcategorias: number
    nombre: string
    imagen: Buffer | null
    _count: CategoriasCountAggregateOutputType | null
    _avg: CategoriasAvgAggregateOutputType | null
    _sum: CategoriasSumAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  type GetCategoriasGroupByPayload<T extends CategoriasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
        }
      >
    >


  export type categoriasSelect = {
    idcategorias?: boolean
    nombre?: boolean
    imagen?: boolean
    publicaciones?: boolean | categorias$publicacionesArgs
    _count?: boolean | CategoriasCountOutputTypeArgs
  }


  export type categoriasInclude = {
    publicaciones?: boolean | categorias$publicacionesArgs
    _count?: boolean | CategoriasCountOutputTypeArgs
  }

  export type categoriasGetPayload<S extends boolean | null | undefined | categoriasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? categorias :
    S extends undefined ? never :
    S extends { include: any } & (categoriasArgs | categoriasFindManyArgs)
    ? categorias  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'publicaciones' ? Array < publicacionesGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoriasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (categoriasArgs | categoriasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'publicaciones' ? Array < publicacionesGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoriasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof categorias ? categorias[P] : never
  } 
      : categorias


  type categoriasCountArgs = 
    Omit<categoriasFindManyArgs, 'select' | 'include'> & {
      select?: CategoriasCountAggregateInputType | true
    }

  export interface categoriasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Categorias that matches the filter.
     * @param {categoriasFindUniqueArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoriasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoriasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categorias'> extends True ? Prisma__categoriasClient<categoriasGetPayload<T>> : Prisma__categoriasClient<categoriasGetPayload<T> | null, null>

    /**
     * Find one Categorias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoriasFindUniqueOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoriasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categoriasFindUniqueOrThrowArgs>
    ): Prisma__categoriasClient<categoriasGetPayload<T>>

    /**
     * Find the first Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoriasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoriasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categorias'> extends True ? Prisma__categoriasClient<categoriasGetPayload<T>> : Prisma__categoriasClient<categoriasGetPayload<T> | null, null>

    /**
     * Find the first Categorias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoriasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categoriasFindFirstOrThrowArgs>
    ): Prisma__categoriasClient<categoriasGetPayload<T>>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categorias.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categorias.findMany({ take: 10 })
     * 
     * // Only select the `idcategorias`
     * const categoriasWithIdcategoriasOnly = await prisma.categorias.findMany({ select: { idcategorias: true } })
     * 
    **/
    findMany<T extends categoriasFindManyArgs>(
      args?: SelectSubset<T, categoriasFindManyArgs>
    ): Prisma.PrismaPromise<Array<categoriasGetPayload<T>>>

    /**
     * Create a Categorias.
     * @param {categoriasCreateArgs} args - Arguments to create a Categorias.
     * @example
     * // Create one Categorias
     * const Categorias = await prisma.categorias.create({
     *   data: {
     *     // ... data to create a Categorias
     *   }
     * })
     * 
    **/
    create<T extends categoriasCreateArgs>(
      args: SelectSubset<T, categoriasCreateArgs>
    ): Prisma__categoriasClient<categoriasGetPayload<T>>

    /**
     * Create many Categorias.
     *     @param {categoriasCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categorias = await prisma.categorias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoriasCreateManyArgs>(
      args?: SelectSubset<T, categoriasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categorias.
     * @param {categoriasDeleteArgs} args - Arguments to delete one Categorias.
     * @example
     * // Delete one Categorias
     * const Categorias = await prisma.categorias.delete({
     *   where: {
     *     // ... filter to delete one Categorias
     *   }
     * })
     * 
    **/
    delete<T extends categoriasDeleteArgs>(
      args: SelectSubset<T, categoriasDeleteArgs>
    ): Prisma__categoriasClient<categoriasGetPayload<T>>

    /**
     * Update one Categorias.
     * @param {categoriasUpdateArgs} args - Arguments to update one Categorias.
     * @example
     * // Update one Categorias
     * const categorias = await prisma.categorias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoriasUpdateArgs>(
      args: SelectSubset<T, categoriasUpdateArgs>
    ): Prisma__categoriasClient<categoriasGetPayload<T>>

    /**
     * Delete zero or more Categorias.
     * @param {categoriasDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categorias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoriasDeleteManyArgs>(
      args?: SelectSubset<T, categoriasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoriasUpdateManyArgs>(
      args: SelectSubset<T, categoriasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categorias.
     * @param {categoriasUpsertArgs} args - Arguments to update or create a Categorias.
     * @example
     * // Update or create a Categorias
     * const categorias = await prisma.categorias.upsert({
     *   create: {
     *     // ... data to create a Categorias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorias we want to update
     *   }
     * })
    **/
    upsert<T extends categoriasUpsertArgs>(
      args: SelectSubset<T, categoriasUpsertArgs>
    ): Prisma__categoriasClient<categoriasGetPayload<T>>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categorias.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriasCountArgs>(
      args?: Subset<T, categoriasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasAggregateArgs>(args: Subset<T, CategoriasAggregateArgs>): Prisma.PrismaPromise<GetCategoriasAggregateType<T>>

    /**
     * Group by Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriasGroupByArgs['orderBy'] }
        : { orderBy?: CategoriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categorias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoriasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    publicaciones<T extends categorias$publicacionesArgs= {}>(args?: Subset<T, categorias$publicacionesArgs>): Prisma.PrismaPromise<Array<publicacionesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categorias base type for findUnique actions
   */
  export type categoriasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findUnique
   */
  export interface categoriasFindUniqueArgs extends categoriasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categorias findUniqueOrThrow
   */
  export type categoriasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }


  /**
   * categorias base type for findFirst actions
   */
  export type categoriasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: Enumerable<categoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: Enumerable<CategoriasScalarFieldEnum>
  }

  /**
   * categorias findFirst
   */
  export interface categoriasFindFirstArgs extends categoriasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categorias findFirstOrThrow
   */
  export type categoriasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: Enumerable<categoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: Enumerable<CategoriasScalarFieldEnum>
  }


  /**
   * categorias findMany
   */
  export type categoriasFindManyArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: Enumerable<categoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: Enumerable<CategoriasScalarFieldEnum>
  }


  /**
   * categorias create
   */
  export type categoriasCreateArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * The data needed to create a categorias.
     */
    data: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
  }


  /**
   * categorias createMany
   */
  export type categoriasCreateManyArgs = {
    /**
     * The data used to create many categorias.
     */
    data: Enumerable<categoriasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * categorias update
   */
  export type categoriasUpdateArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * The data needed to update a categorias.
     */
    data: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
    /**
     * Choose, which categorias to update.
     */
    where: categoriasWhereUniqueInput
  }


  /**
   * categorias updateMany
   */
  export type categoriasUpdateManyArgs = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriasUpdateManyMutationInput, categoriasUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriasWhereInput
  }


  /**
   * categorias upsert
   */
  export type categoriasUpsertArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * The filter to search for the categorias to update in case it exists.
     */
    where: categoriasWhereUniqueInput
    /**
     * In case the categorias found by the `where` argument doesn't exist, create a new categorias with this data.
     */
    create: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
    /**
     * In case the categorias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
  }


  /**
   * categorias delete
   */
  export type categoriasDeleteArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
    /**
     * Filter which categorias to delete.
     */
    where: categoriasWhereUniqueInput
  }


  /**
   * categorias deleteMany
   */
  export type categoriasDeleteManyArgs = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriasWhereInput
  }


  /**
   * categorias.publicaciones
   */
  export type categorias$publicacionesArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    where?: publicacionesWhereInput
    orderBy?: Enumerable<publicacionesOrderByWithRelationInput>
    cursor?: publicacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublicacionesScalarFieldEnum>
  }


  /**
   * categorias without action
   */
  export type categoriasArgs = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriasInclude | null
  }



  /**
   * Model comentarios
   */


  export type AggregateComentarios = {
    _count: ComentariosCountAggregateOutputType | null
    _avg: ComentariosAvgAggregateOutputType | null
    _sum: ComentariosSumAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  export type ComentariosAvgAggregateOutputType = {
    idcomentarios: number | null
    idusuario: number | null
    idpublicacion: number | null
  }

  export type ComentariosSumAggregateOutputType = {
    idcomentarios: number | null
    idusuario: number | null
    idpublicacion: number | null
  }

  export type ComentariosMinAggregateOutputType = {
    idcomentarios: number | null
    descripcion: string | null
    fecha: Date | null
    idusuario: number | null
    idpublicacion: number | null
  }

  export type ComentariosMaxAggregateOutputType = {
    idcomentarios: number | null
    descripcion: string | null
    fecha: Date | null
    idusuario: number | null
    idpublicacion: number | null
  }

  export type ComentariosCountAggregateOutputType = {
    idcomentarios: number
    descripcion: number
    fecha: number
    idusuario: number
    idpublicacion: number
    _all: number
  }


  export type ComentariosAvgAggregateInputType = {
    idcomentarios?: true
    idusuario?: true
    idpublicacion?: true
  }

  export type ComentariosSumAggregateInputType = {
    idcomentarios?: true
    idusuario?: true
    idpublicacion?: true
  }

  export type ComentariosMinAggregateInputType = {
    idcomentarios?: true
    descripcion?: true
    fecha?: true
    idusuario?: true
    idpublicacion?: true
  }

  export type ComentariosMaxAggregateInputType = {
    idcomentarios?: true
    descripcion?: true
    fecha?: true
    idusuario?: true
    idpublicacion?: true
  }

  export type ComentariosCountAggregateInputType = {
    idcomentarios?: true
    descripcion?: true
    fecha?: true
    idusuario?: true
    idpublicacion?: true
    _all?: true
  }

  export type ComentariosAggregateArgs = {
    /**
     * Filter which comentarios to aggregate.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: Enumerable<comentariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comentarios
    **/
    _count?: true | ComentariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentariosMaxAggregateInputType
  }

  export type GetComentariosAggregateType<T extends ComentariosAggregateArgs> = {
        [P in keyof T & keyof AggregateComentarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentarios[P]>
      : GetScalarType<T[P], AggregateComentarios[P]>
  }




  export type ComentariosGroupByArgs = {
    where?: comentariosWhereInput
    orderBy?: Enumerable<comentariosOrderByWithAggregationInput>
    by: ComentariosScalarFieldEnum[]
    having?: comentariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentariosCountAggregateInputType | true
    _avg?: ComentariosAvgAggregateInputType
    _sum?: ComentariosSumAggregateInputType
    _min?: ComentariosMinAggregateInputType
    _max?: ComentariosMaxAggregateInputType
  }


  export type ComentariosGroupByOutputType = {
    idcomentarios: number
    descripcion: string
    fecha: Date
    idusuario: number
    idpublicacion: number
    _count: ComentariosCountAggregateOutputType | null
    _avg: ComentariosAvgAggregateOutputType | null
    _sum: ComentariosSumAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  type GetComentariosGroupByPayload<T extends ComentariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ComentariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
            : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
        }
      >
    >


  export type comentariosSelect = {
    idcomentarios?: boolean
    descripcion?: boolean
    fecha?: boolean
    idusuario?: boolean
    idpublicacion?: boolean
    usuario?: boolean | usuarioArgs
    publicaciones?: boolean | publicacionesArgs
  }


  export type comentariosInclude = {
    usuario?: boolean | usuarioArgs
    publicaciones?: boolean | publicacionesArgs
  }

  export type comentariosGetPayload<S extends boolean | null | undefined | comentariosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? comentarios :
    S extends undefined ? never :
    S extends { include: any } & (comentariosArgs | comentariosFindManyArgs)
    ? comentarios  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'usuario' ? usuarioGetPayload<S['include'][P]> :
        P extends 'publicaciones' ? publicacionesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (comentariosArgs | comentariosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'usuario' ? usuarioGetPayload<S['select'][P]> :
        P extends 'publicaciones' ? publicacionesGetPayload<S['select'][P]> :  P extends keyof comentarios ? comentarios[P] : never
  } 
      : comentarios


  type comentariosCountArgs = 
    Omit<comentariosFindManyArgs, 'select' | 'include'> & {
      select?: ComentariosCountAggregateInputType | true
    }

  export interface comentariosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Comentarios that matches the filter.
     * @param {comentariosFindUniqueArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comentariosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, comentariosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'comentarios'> extends True ? Prisma__comentariosClient<comentariosGetPayload<T>> : Prisma__comentariosClient<comentariosGetPayload<T> | null, null>

    /**
     * Find one Comentarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comentariosFindUniqueOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comentariosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, comentariosFindUniqueOrThrowArgs>
    ): Prisma__comentariosClient<comentariosGetPayload<T>>

    /**
     * Find the first Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindFirstArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comentariosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, comentariosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'comentarios'> extends True ? Prisma__comentariosClient<comentariosGetPayload<T>> : Prisma__comentariosClient<comentariosGetPayload<T> | null, null>

    /**
     * Find the first Comentarios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindFirstOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comentariosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, comentariosFindFirstOrThrowArgs>
    ): Prisma__comentariosClient<comentariosGetPayload<T>>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentarios.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentarios.findMany({ take: 10 })
     * 
     * // Only select the `idcomentarios`
     * const comentariosWithIdcomentariosOnly = await prisma.comentarios.findMany({ select: { idcomentarios: true } })
     * 
    **/
    findMany<T extends comentariosFindManyArgs>(
      args?: SelectSubset<T, comentariosFindManyArgs>
    ): Prisma.PrismaPromise<Array<comentariosGetPayload<T>>>

    /**
     * Create a Comentarios.
     * @param {comentariosCreateArgs} args - Arguments to create a Comentarios.
     * @example
     * // Create one Comentarios
     * const Comentarios = await prisma.comentarios.create({
     *   data: {
     *     // ... data to create a Comentarios
     *   }
     * })
     * 
    **/
    create<T extends comentariosCreateArgs>(
      args: SelectSubset<T, comentariosCreateArgs>
    ): Prisma__comentariosClient<comentariosGetPayload<T>>

    /**
     * Create many Comentarios.
     *     @param {comentariosCreateManyArgs} args - Arguments to create many Comentarios.
     *     @example
     *     // Create many Comentarios
     *     const comentarios = await prisma.comentarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comentariosCreateManyArgs>(
      args?: SelectSubset<T, comentariosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comentarios.
     * @param {comentariosDeleteArgs} args - Arguments to delete one Comentarios.
     * @example
     * // Delete one Comentarios
     * const Comentarios = await prisma.comentarios.delete({
     *   where: {
     *     // ... filter to delete one Comentarios
     *   }
     * })
     * 
    **/
    delete<T extends comentariosDeleteArgs>(
      args: SelectSubset<T, comentariosDeleteArgs>
    ): Prisma__comentariosClient<comentariosGetPayload<T>>

    /**
     * Update one Comentarios.
     * @param {comentariosUpdateArgs} args - Arguments to update one Comentarios.
     * @example
     * // Update one Comentarios
     * const comentarios = await prisma.comentarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comentariosUpdateArgs>(
      args: SelectSubset<T, comentariosUpdateArgs>
    ): Prisma__comentariosClient<comentariosGetPayload<T>>

    /**
     * Delete zero or more Comentarios.
     * @param {comentariosDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comentariosDeleteManyArgs>(
      args?: SelectSubset<T, comentariosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentarios = await prisma.comentarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comentariosUpdateManyArgs>(
      args: SelectSubset<T, comentariosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentarios.
     * @param {comentariosUpsertArgs} args - Arguments to update or create a Comentarios.
     * @example
     * // Update or create a Comentarios
     * const comentarios = await prisma.comentarios.upsert({
     *   create: {
     *     // ... data to create a Comentarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentarios we want to update
     *   }
     * })
    **/
    upsert<T extends comentariosUpsertArgs>(
      args: SelectSubset<T, comentariosUpsertArgs>
    ): Prisma__comentariosClient<comentariosGetPayload<T>>

    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentarios.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends comentariosCountArgs>(
      args?: Subset<T, comentariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentariosAggregateArgs>(args: Subset<T, ComentariosAggregateArgs>): Prisma.PrismaPromise<GetComentariosAggregateType<T>>

    /**
     * Group by Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentariosGroupByArgs['orderBy'] }
        : { orderBy?: ComentariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for comentarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__comentariosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    usuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    publicaciones<T extends publicacionesArgs= {}>(args?: Subset<T, publicacionesArgs>): Prisma__publicacionesClient<publicacionesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * comentarios base type for findUnique actions
   */
  export type comentariosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * Filter, which comentarios to fetch.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios findUnique
   */
  export interface comentariosFindUniqueArgs extends comentariosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comentarios findUniqueOrThrow
   */
  export type comentariosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * Filter, which comentarios to fetch.
     */
    where: comentariosWhereUniqueInput
  }


  /**
   * comentarios base type for findFirst actions
   */
  export type comentariosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: Enumerable<comentariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: Enumerable<ComentariosScalarFieldEnum>
  }

  /**
   * comentarios findFirst
   */
  export interface comentariosFindFirstArgs extends comentariosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comentarios findFirstOrThrow
   */
  export type comentariosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: Enumerable<comentariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: Enumerable<ComentariosScalarFieldEnum>
  }


  /**
   * comentarios findMany
   */
  export type comentariosFindManyArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: Enumerable<comentariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    distinct?: Enumerable<ComentariosScalarFieldEnum>
  }


  /**
   * comentarios create
   */
  export type comentariosCreateArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * The data needed to create a comentarios.
     */
    data: XOR<comentariosCreateInput, comentariosUncheckedCreateInput>
  }


  /**
   * comentarios createMany
   */
  export type comentariosCreateManyArgs = {
    /**
     * The data used to create many comentarios.
     */
    data: Enumerable<comentariosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * comentarios update
   */
  export type comentariosUpdateArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * The data needed to update a comentarios.
     */
    data: XOR<comentariosUpdateInput, comentariosUncheckedUpdateInput>
    /**
     * Choose, which comentarios to update.
     */
    where: comentariosWhereUniqueInput
  }


  /**
   * comentarios updateMany
   */
  export type comentariosUpdateManyArgs = {
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentariosWhereInput
  }


  /**
   * comentarios upsert
   */
  export type comentariosUpsertArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * The filter to search for the comentarios to update in case it exists.
     */
    where: comentariosWhereUniqueInput
    /**
     * In case the comentarios found by the `where` argument doesn't exist, create a new comentarios with this data.
     */
    create: XOR<comentariosCreateInput, comentariosUncheckedCreateInput>
    /**
     * In case the comentarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comentariosUpdateInput, comentariosUncheckedUpdateInput>
  }


  /**
   * comentarios delete
   */
  export type comentariosDeleteArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    /**
     * Filter which comentarios to delete.
     */
    where: comentariosWhereUniqueInput
  }


  /**
   * comentarios deleteMany
   */
  export type comentariosDeleteManyArgs = {
    /**
     * Filter which comentarios to delete
     */
    where?: comentariosWhereInput
  }


  /**
   * comentarios without action
   */
  export type comentariosArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
  }



  /**
   * Model imagen
   */


  export type AggregateImagen = {
    _count: ImagenCountAggregateOutputType | null
    _avg: ImagenAvgAggregateOutputType | null
    _sum: ImagenSumAggregateOutputType | null
    _min: ImagenMinAggregateOutputType | null
    _max: ImagenMaxAggregateOutputType | null
  }

  export type ImagenAvgAggregateOutputType = {
    idimagen: number | null
    idpublicacion: number | null
  }

  export type ImagenSumAggregateOutputType = {
    idimagen: number | null
    idpublicacion: number | null
  }

  export type ImagenMinAggregateOutputType = {
    idimagen: number | null
    imagen: Buffer | null
    idpublicacion: number | null
  }

  export type ImagenMaxAggregateOutputType = {
    idimagen: number | null
    imagen: Buffer | null
    idpublicacion: number | null
  }

  export type ImagenCountAggregateOutputType = {
    idimagen: number
    imagen: number
    idpublicacion: number
    _all: number
  }


  export type ImagenAvgAggregateInputType = {
    idimagen?: true
    idpublicacion?: true
  }

  export type ImagenSumAggregateInputType = {
    idimagen?: true
    idpublicacion?: true
  }

  export type ImagenMinAggregateInputType = {
    idimagen?: true
    imagen?: true
    idpublicacion?: true
  }

  export type ImagenMaxAggregateInputType = {
    idimagen?: true
    imagen?: true
    idpublicacion?: true
  }

  export type ImagenCountAggregateInputType = {
    idimagen?: true
    imagen?: true
    idpublicacion?: true
    _all?: true
  }

  export type ImagenAggregateArgs = {
    /**
     * Filter which imagen to aggregate.
     */
    where?: imagenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imagens to fetch.
     */
    orderBy?: Enumerable<imagenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imagenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imagens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned imagens
    **/
    _count?: true | ImagenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagenMaxAggregateInputType
  }

  export type GetImagenAggregateType<T extends ImagenAggregateArgs> = {
        [P in keyof T & keyof AggregateImagen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImagen[P]>
      : GetScalarType<T[P], AggregateImagen[P]>
  }




  export type ImagenGroupByArgs = {
    where?: imagenWhereInput
    orderBy?: Enumerable<imagenOrderByWithAggregationInput>
    by: ImagenScalarFieldEnum[]
    having?: imagenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagenCountAggregateInputType | true
    _avg?: ImagenAvgAggregateInputType
    _sum?: ImagenSumAggregateInputType
    _min?: ImagenMinAggregateInputType
    _max?: ImagenMaxAggregateInputType
  }


  export type ImagenGroupByOutputType = {
    idimagen: number
    imagen: Buffer
    idpublicacion: number
    _count: ImagenCountAggregateOutputType | null
    _avg: ImagenAvgAggregateOutputType | null
    _sum: ImagenSumAggregateOutputType | null
    _min: ImagenMinAggregateOutputType | null
    _max: ImagenMaxAggregateOutputType | null
  }

  type GetImagenGroupByPayload<T extends ImagenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImagenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagenGroupByOutputType[P]>
            : GetScalarType<T[P], ImagenGroupByOutputType[P]>
        }
      >
    >


  export type imagenSelect = {
    idimagen?: boolean
    imagen?: boolean
    idpublicacion?: boolean
    publicaciones?: boolean | publicacionesArgs
  }


  export type imagenInclude = {
    publicaciones?: boolean | publicacionesArgs
  }

  export type imagenGetPayload<S extends boolean | null | undefined | imagenArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? imagen :
    S extends undefined ? never :
    S extends { include: any } & (imagenArgs | imagenFindManyArgs)
    ? imagen  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'publicaciones' ? publicacionesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (imagenArgs | imagenFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'publicaciones' ? publicacionesGetPayload<S['select'][P]> :  P extends keyof imagen ? imagen[P] : never
  } 
      : imagen


  type imagenCountArgs = 
    Omit<imagenFindManyArgs, 'select' | 'include'> & {
      select?: ImagenCountAggregateInputType | true
    }

  export interface imagenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Imagen that matches the filter.
     * @param {imagenFindUniqueArgs} args - Arguments to find a Imagen
     * @example
     * // Get one Imagen
     * const imagen = await prisma.imagen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends imagenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, imagenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'imagen'> extends True ? Prisma__imagenClient<imagenGetPayload<T>> : Prisma__imagenClient<imagenGetPayload<T> | null, null>

    /**
     * Find one Imagen that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {imagenFindUniqueOrThrowArgs} args - Arguments to find a Imagen
     * @example
     * // Get one Imagen
     * const imagen = await prisma.imagen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends imagenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, imagenFindUniqueOrThrowArgs>
    ): Prisma__imagenClient<imagenGetPayload<T>>

    /**
     * Find the first Imagen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagenFindFirstArgs} args - Arguments to find a Imagen
     * @example
     * // Get one Imagen
     * const imagen = await prisma.imagen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends imagenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, imagenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'imagen'> extends True ? Prisma__imagenClient<imagenGetPayload<T>> : Prisma__imagenClient<imagenGetPayload<T> | null, null>

    /**
     * Find the first Imagen that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagenFindFirstOrThrowArgs} args - Arguments to find a Imagen
     * @example
     * // Get one Imagen
     * const imagen = await prisma.imagen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends imagenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, imagenFindFirstOrThrowArgs>
    ): Prisma__imagenClient<imagenGetPayload<T>>

    /**
     * Find zero or more Imagens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Imagens
     * const imagens = await prisma.imagen.findMany()
     * 
     * // Get first 10 Imagens
     * const imagens = await prisma.imagen.findMany({ take: 10 })
     * 
     * // Only select the `idimagen`
     * const imagenWithIdimagenOnly = await prisma.imagen.findMany({ select: { idimagen: true } })
     * 
    **/
    findMany<T extends imagenFindManyArgs>(
      args?: SelectSubset<T, imagenFindManyArgs>
    ): Prisma.PrismaPromise<Array<imagenGetPayload<T>>>

    /**
     * Create a Imagen.
     * @param {imagenCreateArgs} args - Arguments to create a Imagen.
     * @example
     * // Create one Imagen
     * const Imagen = await prisma.imagen.create({
     *   data: {
     *     // ... data to create a Imagen
     *   }
     * })
     * 
    **/
    create<T extends imagenCreateArgs>(
      args: SelectSubset<T, imagenCreateArgs>
    ): Prisma__imagenClient<imagenGetPayload<T>>

    /**
     * Create many Imagens.
     *     @param {imagenCreateManyArgs} args - Arguments to create many Imagens.
     *     @example
     *     // Create many Imagens
     *     const imagen = await prisma.imagen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends imagenCreateManyArgs>(
      args?: SelectSubset<T, imagenCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Imagen.
     * @param {imagenDeleteArgs} args - Arguments to delete one Imagen.
     * @example
     * // Delete one Imagen
     * const Imagen = await prisma.imagen.delete({
     *   where: {
     *     // ... filter to delete one Imagen
     *   }
     * })
     * 
    **/
    delete<T extends imagenDeleteArgs>(
      args: SelectSubset<T, imagenDeleteArgs>
    ): Prisma__imagenClient<imagenGetPayload<T>>

    /**
     * Update one Imagen.
     * @param {imagenUpdateArgs} args - Arguments to update one Imagen.
     * @example
     * // Update one Imagen
     * const imagen = await prisma.imagen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends imagenUpdateArgs>(
      args: SelectSubset<T, imagenUpdateArgs>
    ): Prisma__imagenClient<imagenGetPayload<T>>

    /**
     * Delete zero or more Imagens.
     * @param {imagenDeleteManyArgs} args - Arguments to filter Imagens to delete.
     * @example
     * // Delete a few Imagens
     * const { count } = await prisma.imagen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends imagenDeleteManyArgs>(
      args?: SelectSubset<T, imagenDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Imagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Imagens
     * const imagen = await prisma.imagen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends imagenUpdateManyArgs>(
      args: SelectSubset<T, imagenUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Imagen.
     * @param {imagenUpsertArgs} args - Arguments to update or create a Imagen.
     * @example
     * // Update or create a Imagen
     * const imagen = await prisma.imagen.upsert({
     *   create: {
     *     // ... data to create a Imagen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Imagen we want to update
     *   }
     * })
    **/
    upsert<T extends imagenUpsertArgs>(
      args: SelectSubset<T, imagenUpsertArgs>
    ): Prisma__imagenClient<imagenGetPayload<T>>

    /**
     * Count the number of Imagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagenCountArgs} args - Arguments to filter Imagens to count.
     * @example
     * // Count the number of Imagens
     * const count = await prisma.imagen.count({
     *   where: {
     *     // ... the filter for the Imagens we want to count
     *   }
     * })
    **/
    count<T extends imagenCountArgs>(
      args?: Subset<T, imagenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Imagen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagenAggregateArgs>(args: Subset<T, ImagenAggregateArgs>): Prisma.PrismaPromise<GetImagenAggregateType<T>>

    /**
     * Group by Imagen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagenGroupByArgs['orderBy'] }
        : { orderBy?: ImagenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for imagen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__imagenClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    publicaciones<T extends publicacionesArgs= {}>(args?: Subset<T, publicacionesArgs>): Prisma__publicacionesClient<publicacionesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * imagen base type for findUnique actions
   */
  export type imagenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * Filter, which imagen to fetch.
     */
    where: imagenWhereUniqueInput
  }

  /**
   * imagen findUnique
   */
  export interface imagenFindUniqueArgs extends imagenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * imagen findUniqueOrThrow
   */
  export type imagenFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * Filter, which imagen to fetch.
     */
    where: imagenWhereUniqueInput
  }


  /**
   * imagen base type for findFirst actions
   */
  export type imagenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * Filter, which imagen to fetch.
     */
    where?: imagenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imagens to fetch.
     */
    orderBy?: Enumerable<imagenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for imagens.
     */
    cursor?: imagenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imagens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of imagens.
     */
    distinct?: Enumerable<ImagenScalarFieldEnum>
  }

  /**
   * imagen findFirst
   */
  export interface imagenFindFirstArgs extends imagenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * imagen findFirstOrThrow
   */
  export type imagenFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * Filter, which imagen to fetch.
     */
    where?: imagenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imagens to fetch.
     */
    orderBy?: Enumerable<imagenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for imagens.
     */
    cursor?: imagenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imagens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of imagens.
     */
    distinct?: Enumerable<ImagenScalarFieldEnum>
  }


  /**
   * imagen findMany
   */
  export type imagenFindManyArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * Filter, which imagens to fetch.
     */
    where?: imagenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imagens to fetch.
     */
    orderBy?: Enumerable<imagenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing imagens.
     */
    cursor?: imagenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imagens.
     */
    skip?: number
    distinct?: Enumerable<ImagenScalarFieldEnum>
  }


  /**
   * imagen create
   */
  export type imagenCreateArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * The data needed to create a imagen.
     */
    data: XOR<imagenCreateInput, imagenUncheckedCreateInput>
  }


  /**
   * imagen createMany
   */
  export type imagenCreateManyArgs = {
    /**
     * The data used to create many imagens.
     */
    data: Enumerable<imagenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * imagen update
   */
  export type imagenUpdateArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * The data needed to update a imagen.
     */
    data: XOR<imagenUpdateInput, imagenUncheckedUpdateInput>
    /**
     * Choose, which imagen to update.
     */
    where: imagenWhereUniqueInput
  }


  /**
   * imagen updateMany
   */
  export type imagenUpdateManyArgs = {
    /**
     * The data used to update imagens.
     */
    data: XOR<imagenUpdateManyMutationInput, imagenUncheckedUpdateManyInput>
    /**
     * Filter which imagens to update
     */
    where?: imagenWhereInput
  }


  /**
   * imagen upsert
   */
  export type imagenUpsertArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * The filter to search for the imagen to update in case it exists.
     */
    where: imagenWhereUniqueInput
    /**
     * In case the imagen found by the `where` argument doesn't exist, create a new imagen with this data.
     */
    create: XOR<imagenCreateInput, imagenUncheckedCreateInput>
    /**
     * In case the imagen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imagenUpdateInput, imagenUncheckedUpdateInput>
  }


  /**
   * imagen delete
   */
  export type imagenDeleteArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    /**
     * Filter which imagen to delete.
     */
    where: imagenWhereUniqueInput
  }


  /**
   * imagen deleteMany
   */
  export type imagenDeleteManyArgs = {
    /**
     * Filter which imagens to delete
     */
    where?: imagenWhereInput
  }


  /**
   * imagen without action
   */
  export type imagenArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
  }



  /**
   * Model publicaciones
   */


  export type AggregatePublicaciones = {
    _count: PublicacionesCountAggregateOutputType | null
    _avg: PublicacionesAvgAggregateOutputType | null
    _sum: PublicacionesSumAggregateOutputType | null
    _min: PublicacionesMinAggregateOutputType | null
    _max: PublicacionesMaxAggregateOutputType | null
  }

  export type PublicacionesAvgAggregateOutputType = {
    idpublicaciones: number | null
    idcategoria: number | null
    idusuario: number | null
  }

  export type PublicacionesSumAggregateOutputType = {
    idpublicaciones: number | null
    idcategoria: number | null
    idusuario: number | null
  }

  export type PublicacionesMinAggregateOutputType = {
    idpublicaciones: number | null
    titulo: string | null
    descripcion: string | null
    idcategoria: number | null
    idusuario: number | null
  }

  export type PublicacionesMaxAggregateOutputType = {
    idpublicaciones: number | null
    titulo: string | null
    descripcion: string | null
    idcategoria: number | null
    idusuario: number | null
  }

  export type PublicacionesCountAggregateOutputType = {
    idpublicaciones: number
    titulo: number
    descripcion: number
    idcategoria: number
    idusuario: number
    _all: number
  }


  export type PublicacionesAvgAggregateInputType = {
    idpublicaciones?: true
    idcategoria?: true
    idusuario?: true
  }

  export type PublicacionesSumAggregateInputType = {
    idpublicaciones?: true
    idcategoria?: true
    idusuario?: true
  }

  export type PublicacionesMinAggregateInputType = {
    idpublicaciones?: true
    titulo?: true
    descripcion?: true
    idcategoria?: true
    idusuario?: true
  }

  export type PublicacionesMaxAggregateInputType = {
    idpublicaciones?: true
    titulo?: true
    descripcion?: true
    idcategoria?: true
    idusuario?: true
  }

  export type PublicacionesCountAggregateInputType = {
    idpublicaciones?: true
    titulo?: true
    descripcion?: true
    idcategoria?: true
    idusuario?: true
    _all?: true
  }

  export type PublicacionesAggregateArgs = {
    /**
     * Filter which publicaciones to aggregate.
     */
    where?: publicacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicaciones to fetch.
     */
    orderBy?: Enumerable<publicacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publicacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publicaciones
    **/
    _count?: true | PublicacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicacionesMaxAggregateInputType
  }

  export type GetPublicacionesAggregateType<T extends PublicacionesAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicaciones[P]>
      : GetScalarType<T[P], AggregatePublicaciones[P]>
  }




  export type PublicacionesGroupByArgs = {
    where?: publicacionesWhereInput
    orderBy?: Enumerable<publicacionesOrderByWithAggregationInput>
    by: PublicacionesScalarFieldEnum[]
    having?: publicacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicacionesCountAggregateInputType | true
    _avg?: PublicacionesAvgAggregateInputType
    _sum?: PublicacionesSumAggregateInputType
    _min?: PublicacionesMinAggregateInputType
    _max?: PublicacionesMaxAggregateInputType
  }


  export type PublicacionesGroupByOutputType = {
    idpublicaciones: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
    _count: PublicacionesCountAggregateOutputType | null
    _avg: PublicacionesAvgAggregateOutputType | null
    _sum: PublicacionesSumAggregateOutputType | null
    _min: PublicacionesMinAggregateOutputType | null
    _max: PublicacionesMaxAggregateOutputType | null
  }

  type GetPublicacionesGroupByPayload<T extends PublicacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PublicacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicacionesGroupByOutputType[P]>
            : GetScalarType<T[P], PublicacionesGroupByOutputType[P]>
        }
      >
    >


  export type publicacionesSelect = {
    idpublicaciones?: boolean
    titulo?: boolean
    descripcion?: boolean
    idcategoria?: boolean
    idusuario?: boolean
    comentarios?: boolean | publicaciones$comentariosArgs
    imagen?: boolean | publicaciones$imagenArgs
    categorias?: boolean | categoriasArgs
    usuario?: boolean | usuarioArgs
    publicacionesguardadas?: boolean | publicaciones$publicacionesguardadasArgs
    publicacionestablero?: boolean | publicaciones$publicacionestableroArgs
    _count?: boolean | PublicacionesCountOutputTypeArgs
  }


  export type publicacionesInclude = {
    comentarios?: boolean | publicaciones$comentariosArgs
    imagen?: boolean | publicaciones$imagenArgs
    categorias?: boolean | categoriasArgs
    usuario?: boolean | usuarioArgs
    publicacionesguardadas?: boolean | publicaciones$publicacionesguardadasArgs
    publicacionestablero?: boolean | publicaciones$publicacionestableroArgs
    _count?: boolean | PublicacionesCountOutputTypeArgs
  }

  export type publicacionesGetPayload<S extends boolean | null | undefined | publicacionesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? publicaciones :
    S extends undefined ? never :
    S extends { include: any } & (publicacionesArgs | publicacionesFindManyArgs)
    ? publicaciones  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'comentarios' ? Array < comentariosGetPayload<S['include'][P]>>  :
        P extends 'imagen' ? Array < imagenGetPayload<S['include'][P]>>  :
        P extends 'categorias' ? categoriasGetPayload<S['include'][P]> :
        P extends 'usuario' ? usuarioGetPayload<S['include'][P]> :
        P extends 'publicacionesguardadas' ? Array < publicacionesguardadasGetPayload<S['include'][P]>>  :
        P extends 'publicacionestablero' ? Array < publicacionestableroGetPayload<S['include'][P]>>  :
        P extends '_count' ? PublicacionesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (publicacionesArgs | publicacionesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'comentarios' ? Array < comentariosGetPayload<S['select'][P]>>  :
        P extends 'imagen' ? Array < imagenGetPayload<S['select'][P]>>  :
        P extends 'categorias' ? categoriasGetPayload<S['select'][P]> :
        P extends 'usuario' ? usuarioGetPayload<S['select'][P]> :
        P extends 'publicacionesguardadas' ? Array < publicacionesguardadasGetPayload<S['select'][P]>>  :
        P extends 'publicacionestablero' ? Array < publicacionestableroGetPayload<S['select'][P]>>  :
        P extends '_count' ? PublicacionesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof publicaciones ? publicaciones[P] : never
  } 
      : publicaciones


  type publicacionesCountArgs = 
    Omit<publicacionesFindManyArgs, 'select' | 'include'> & {
      select?: PublicacionesCountAggregateInputType | true
    }

  export interface publicacionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Publicaciones that matches the filter.
     * @param {publicacionesFindUniqueArgs} args - Arguments to find a Publicaciones
     * @example
     * // Get one Publicaciones
     * const publicaciones = await prisma.publicaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends publicacionesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, publicacionesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'publicaciones'> extends True ? Prisma__publicacionesClient<publicacionesGetPayload<T>> : Prisma__publicacionesClient<publicacionesGetPayload<T> | null, null>

    /**
     * Find one Publicaciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {publicacionesFindUniqueOrThrowArgs} args - Arguments to find a Publicaciones
     * @example
     * // Get one Publicaciones
     * const publicaciones = await prisma.publicaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends publicacionesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, publicacionesFindUniqueOrThrowArgs>
    ): Prisma__publicacionesClient<publicacionesGetPayload<T>>

    /**
     * Find the first Publicaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesFindFirstArgs} args - Arguments to find a Publicaciones
     * @example
     * // Get one Publicaciones
     * const publicaciones = await prisma.publicaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends publicacionesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, publicacionesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'publicaciones'> extends True ? Prisma__publicacionesClient<publicacionesGetPayload<T>> : Prisma__publicacionesClient<publicacionesGetPayload<T> | null, null>

    /**
     * Find the first Publicaciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesFindFirstOrThrowArgs} args - Arguments to find a Publicaciones
     * @example
     * // Get one Publicaciones
     * const publicaciones = await prisma.publicaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends publicacionesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, publicacionesFindFirstOrThrowArgs>
    ): Prisma__publicacionesClient<publicacionesGetPayload<T>>

    /**
     * Find zero or more Publicaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publicaciones
     * const publicaciones = await prisma.publicaciones.findMany()
     * 
     * // Get first 10 Publicaciones
     * const publicaciones = await prisma.publicaciones.findMany({ take: 10 })
     * 
     * // Only select the `idpublicaciones`
     * const publicacionesWithIdpublicacionesOnly = await prisma.publicaciones.findMany({ select: { idpublicaciones: true } })
     * 
    **/
    findMany<T extends publicacionesFindManyArgs>(
      args?: SelectSubset<T, publicacionesFindManyArgs>
    ): Prisma.PrismaPromise<Array<publicacionesGetPayload<T>>>

    /**
     * Create a Publicaciones.
     * @param {publicacionesCreateArgs} args - Arguments to create a Publicaciones.
     * @example
     * // Create one Publicaciones
     * const Publicaciones = await prisma.publicaciones.create({
     *   data: {
     *     // ... data to create a Publicaciones
     *   }
     * })
     * 
    **/
    create<T extends publicacionesCreateArgs>(
      args: SelectSubset<T, publicacionesCreateArgs>
    ): Prisma__publicacionesClient<publicacionesGetPayload<T>>

    /**
     * Create many Publicaciones.
     *     @param {publicacionesCreateManyArgs} args - Arguments to create many Publicaciones.
     *     @example
     *     // Create many Publicaciones
     *     const publicaciones = await prisma.publicaciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends publicacionesCreateManyArgs>(
      args?: SelectSubset<T, publicacionesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publicaciones.
     * @param {publicacionesDeleteArgs} args - Arguments to delete one Publicaciones.
     * @example
     * // Delete one Publicaciones
     * const Publicaciones = await prisma.publicaciones.delete({
     *   where: {
     *     // ... filter to delete one Publicaciones
     *   }
     * })
     * 
    **/
    delete<T extends publicacionesDeleteArgs>(
      args: SelectSubset<T, publicacionesDeleteArgs>
    ): Prisma__publicacionesClient<publicacionesGetPayload<T>>

    /**
     * Update one Publicaciones.
     * @param {publicacionesUpdateArgs} args - Arguments to update one Publicaciones.
     * @example
     * // Update one Publicaciones
     * const publicaciones = await prisma.publicaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends publicacionesUpdateArgs>(
      args: SelectSubset<T, publicacionesUpdateArgs>
    ): Prisma__publicacionesClient<publicacionesGetPayload<T>>

    /**
     * Delete zero or more Publicaciones.
     * @param {publicacionesDeleteManyArgs} args - Arguments to filter Publicaciones to delete.
     * @example
     * // Delete a few Publicaciones
     * const { count } = await prisma.publicaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends publicacionesDeleteManyArgs>(
      args?: SelectSubset<T, publicacionesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publicaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publicaciones
     * const publicaciones = await prisma.publicaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends publicacionesUpdateManyArgs>(
      args: SelectSubset<T, publicacionesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publicaciones.
     * @param {publicacionesUpsertArgs} args - Arguments to update or create a Publicaciones.
     * @example
     * // Update or create a Publicaciones
     * const publicaciones = await prisma.publicaciones.upsert({
     *   create: {
     *     // ... data to create a Publicaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publicaciones we want to update
     *   }
     * })
    **/
    upsert<T extends publicacionesUpsertArgs>(
      args: SelectSubset<T, publicacionesUpsertArgs>
    ): Prisma__publicacionesClient<publicacionesGetPayload<T>>

    /**
     * Count the number of Publicaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesCountArgs} args - Arguments to filter Publicaciones to count.
     * @example
     * // Count the number of Publicaciones
     * const count = await prisma.publicaciones.count({
     *   where: {
     *     // ... the filter for the Publicaciones we want to count
     *   }
     * })
    **/
    count<T extends publicacionesCountArgs>(
      args?: Subset<T, publicacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publicaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicacionesAggregateArgs>(args: Subset<T, PublicacionesAggregateArgs>): Prisma.PrismaPromise<GetPublicacionesAggregateType<T>>

    /**
     * Group by Publicaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicacionesGroupByArgs['orderBy'] }
        : { orderBy?: PublicacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for publicaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__publicacionesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comentarios<T extends publicaciones$comentariosArgs= {}>(args?: Subset<T, publicaciones$comentariosArgs>): Prisma.PrismaPromise<Array<comentariosGetPayload<T>>| Null>;

    imagen<T extends publicaciones$imagenArgs= {}>(args?: Subset<T, publicaciones$imagenArgs>): Prisma.PrismaPromise<Array<imagenGetPayload<T>>| Null>;

    categorias<T extends categoriasArgs= {}>(args?: Subset<T, categoriasArgs>): Prisma__categoriasClient<categoriasGetPayload<T> | Null>;

    usuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    publicacionesguardadas<T extends publicaciones$publicacionesguardadasArgs= {}>(args?: Subset<T, publicaciones$publicacionesguardadasArgs>): Prisma.PrismaPromise<Array<publicacionesguardadasGetPayload<T>>| Null>;

    publicacionestablero<T extends publicaciones$publicacionestableroArgs= {}>(args?: Subset<T, publicaciones$publicacionestableroArgs>): Prisma.PrismaPromise<Array<publicacionestableroGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * publicaciones base type for findUnique actions
   */
  export type publicacionesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * Filter, which publicaciones to fetch.
     */
    where: publicacionesWhereUniqueInput
  }

  /**
   * publicaciones findUnique
   */
  export interface publicacionesFindUniqueArgs extends publicacionesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicaciones findUniqueOrThrow
   */
  export type publicacionesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * Filter, which publicaciones to fetch.
     */
    where: publicacionesWhereUniqueInput
  }


  /**
   * publicaciones base type for findFirst actions
   */
  export type publicacionesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * Filter, which publicaciones to fetch.
     */
    where?: publicacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicaciones to fetch.
     */
    orderBy?: Enumerable<publicacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicaciones.
     */
    cursor?: publicacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicaciones.
     */
    distinct?: Enumerable<PublicacionesScalarFieldEnum>
  }

  /**
   * publicaciones findFirst
   */
  export interface publicacionesFindFirstArgs extends publicacionesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicaciones findFirstOrThrow
   */
  export type publicacionesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * Filter, which publicaciones to fetch.
     */
    where?: publicacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicaciones to fetch.
     */
    orderBy?: Enumerable<publicacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicaciones.
     */
    cursor?: publicacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicaciones.
     */
    distinct?: Enumerable<PublicacionesScalarFieldEnum>
  }


  /**
   * publicaciones findMany
   */
  export type publicacionesFindManyArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * Filter, which publicaciones to fetch.
     */
    where?: publicacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicaciones to fetch.
     */
    orderBy?: Enumerable<publicacionesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publicaciones.
     */
    cursor?: publicacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicaciones.
     */
    skip?: number
    distinct?: Enumerable<PublicacionesScalarFieldEnum>
  }


  /**
   * publicaciones create
   */
  export type publicacionesCreateArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * The data needed to create a publicaciones.
     */
    data: XOR<publicacionesCreateInput, publicacionesUncheckedCreateInput>
  }


  /**
   * publicaciones createMany
   */
  export type publicacionesCreateManyArgs = {
    /**
     * The data used to create many publicaciones.
     */
    data: Enumerable<publicacionesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * publicaciones update
   */
  export type publicacionesUpdateArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * The data needed to update a publicaciones.
     */
    data: XOR<publicacionesUpdateInput, publicacionesUncheckedUpdateInput>
    /**
     * Choose, which publicaciones to update.
     */
    where: publicacionesWhereUniqueInput
  }


  /**
   * publicaciones updateMany
   */
  export type publicacionesUpdateManyArgs = {
    /**
     * The data used to update publicaciones.
     */
    data: XOR<publicacionesUpdateManyMutationInput, publicacionesUncheckedUpdateManyInput>
    /**
     * Filter which publicaciones to update
     */
    where?: publicacionesWhereInput
  }


  /**
   * publicaciones upsert
   */
  export type publicacionesUpsertArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * The filter to search for the publicaciones to update in case it exists.
     */
    where: publicacionesWhereUniqueInput
    /**
     * In case the publicaciones found by the `where` argument doesn't exist, create a new publicaciones with this data.
     */
    create: XOR<publicacionesCreateInput, publicacionesUncheckedCreateInput>
    /**
     * In case the publicaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publicacionesUpdateInput, publicacionesUncheckedUpdateInput>
  }


  /**
   * publicaciones delete
   */
  export type publicacionesDeleteArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    /**
     * Filter which publicaciones to delete.
     */
    where: publicacionesWhereUniqueInput
  }


  /**
   * publicaciones deleteMany
   */
  export type publicacionesDeleteManyArgs = {
    /**
     * Filter which publicaciones to delete
     */
    where?: publicacionesWhereInput
  }


  /**
   * publicaciones.comentarios
   */
  export type publicaciones$comentariosArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    where?: comentariosWhereInput
    orderBy?: Enumerable<comentariosOrderByWithRelationInput>
    cursor?: comentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ComentariosScalarFieldEnum>
  }


  /**
   * publicaciones.imagen
   */
  export type publicaciones$imagenArgs = {
    /**
     * Select specific fields to fetch from the imagen
     */
    select?: imagenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagenInclude | null
    where?: imagenWhereInput
    orderBy?: Enumerable<imagenOrderByWithRelationInput>
    cursor?: imagenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImagenScalarFieldEnum>
  }


  /**
   * publicaciones.publicacionesguardadas
   */
  export type publicaciones$publicacionesguardadasArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    where?: publicacionesguardadasWhereInput
    orderBy?: Enumerable<publicacionesguardadasOrderByWithRelationInput>
    cursor?: publicacionesguardadasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublicacionesguardadasScalarFieldEnum>
  }


  /**
   * publicaciones.publicacionestablero
   */
  export type publicaciones$publicacionestableroArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    where?: publicacionestableroWhereInput
    orderBy?: Enumerable<publicacionestableroOrderByWithRelationInput>
    cursor?: publicacionestableroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublicacionestableroScalarFieldEnum>
  }


  /**
   * publicaciones without action
   */
  export type publicacionesArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
  }



  /**
   * Model publicacionesguardadas
   */


  export type AggregatePublicacionesguardadas = {
    _count: PublicacionesguardadasCountAggregateOutputType | null
    _avg: PublicacionesguardadasAvgAggregateOutputType | null
    _sum: PublicacionesguardadasSumAggregateOutputType | null
    _min: PublicacionesguardadasMinAggregateOutputType | null
    _max: PublicacionesguardadasMaxAggregateOutputType | null
  }

  export type PublicacionesguardadasAvgAggregateOutputType = {
    idpublicacionesguardadas: number | null
    idpublicacion: number | null
    idusuario: number | null
  }

  export type PublicacionesguardadasSumAggregateOutputType = {
    idpublicacionesguardadas: number | null
    idpublicacion: number | null
    idusuario: number | null
  }

  export type PublicacionesguardadasMinAggregateOutputType = {
    idpublicacionesguardadas: number | null
    idpublicacion: number | null
    idusuario: number | null
  }

  export type PublicacionesguardadasMaxAggregateOutputType = {
    idpublicacionesguardadas: number | null
    idpublicacion: number | null
    idusuario: number | null
  }

  export type PublicacionesguardadasCountAggregateOutputType = {
    idpublicacionesguardadas: number
    idpublicacion: number
    idusuario: number
    _all: number
  }


  export type PublicacionesguardadasAvgAggregateInputType = {
    idpublicacionesguardadas?: true
    idpublicacion?: true
    idusuario?: true
  }

  export type PublicacionesguardadasSumAggregateInputType = {
    idpublicacionesguardadas?: true
    idpublicacion?: true
    idusuario?: true
  }

  export type PublicacionesguardadasMinAggregateInputType = {
    idpublicacionesguardadas?: true
    idpublicacion?: true
    idusuario?: true
  }

  export type PublicacionesguardadasMaxAggregateInputType = {
    idpublicacionesguardadas?: true
    idpublicacion?: true
    idusuario?: true
  }

  export type PublicacionesguardadasCountAggregateInputType = {
    idpublicacionesguardadas?: true
    idpublicacion?: true
    idusuario?: true
    _all?: true
  }

  export type PublicacionesguardadasAggregateArgs = {
    /**
     * Filter which publicacionesguardadas to aggregate.
     */
    where?: publicacionesguardadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionesguardadas to fetch.
     */
    orderBy?: Enumerable<publicacionesguardadasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publicacionesguardadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionesguardadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionesguardadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publicacionesguardadas
    **/
    _count?: true | PublicacionesguardadasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicacionesguardadasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicacionesguardadasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicacionesguardadasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicacionesguardadasMaxAggregateInputType
  }

  export type GetPublicacionesguardadasAggregateType<T extends PublicacionesguardadasAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicacionesguardadas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicacionesguardadas[P]>
      : GetScalarType<T[P], AggregatePublicacionesguardadas[P]>
  }




  export type PublicacionesguardadasGroupByArgs = {
    where?: publicacionesguardadasWhereInput
    orderBy?: Enumerable<publicacionesguardadasOrderByWithAggregationInput>
    by: PublicacionesguardadasScalarFieldEnum[]
    having?: publicacionesguardadasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicacionesguardadasCountAggregateInputType | true
    _avg?: PublicacionesguardadasAvgAggregateInputType
    _sum?: PublicacionesguardadasSumAggregateInputType
    _min?: PublicacionesguardadasMinAggregateInputType
    _max?: PublicacionesguardadasMaxAggregateInputType
  }


  export type PublicacionesguardadasGroupByOutputType = {
    idpublicacionesguardadas: number
    idpublicacion: number
    idusuario: number
    _count: PublicacionesguardadasCountAggregateOutputType | null
    _avg: PublicacionesguardadasAvgAggregateOutputType | null
    _sum: PublicacionesguardadasSumAggregateOutputType | null
    _min: PublicacionesguardadasMinAggregateOutputType | null
    _max: PublicacionesguardadasMaxAggregateOutputType | null
  }

  type GetPublicacionesguardadasGroupByPayload<T extends PublicacionesguardadasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PublicacionesguardadasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicacionesguardadasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicacionesguardadasGroupByOutputType[P]>
            : GetScalarType<T[P], PublicacionesguardadasGroupByOutputType[P]>
        }
      >
    >


  export type publicacionesguardadasSelect = {
    idpublicacionesguardadas?: boolean
    idpublicacion?: boolean
    idusuario?: boolean
    publicaciones?: boolean | publicacionesArgs
    usuario?: boolean | usuarioArgs
  }


  export type publicacionesguardadasInclude = {
    publicaciones?: boolean | publicacionesArgs
    usuario?: boolean | usuarioArgs
  }

  export type publicacionesguardadasGetPayload<S extends boolean | null | undefined | publicacionesguardadasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? publicacionesguardadas :
    S extends undefined ? never :
    S extends { include: any } & (publicacionesguardadasArgs | publicacionesguardadasFindManyArgs)
    ? publicacionesguardadas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'publicaciones' ? publicacionesGetPayload<S['include'][P]> :
        P extends 'usuario' ? usuarioGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (publicacionesguardadasArgs | publicacionesguardadasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'publicaciones' ? publicacionesGetPayload<S['select'][P]> :
        P extends 'usuario' ? usuarioGetPayload<S['select'][P]> :  P extends keyof publicacionesguardadas ? publicacionesguardadas[P] : never
  } 
      : publicacionesguardadas


  type publicacionesguardadasCountArgs = 
    Omit<publicacionesguardadasFindManyArgs, 'select' | 'include'> & {
      select?: PublicacionesguardadasCountAggregateInputType | true
    }

  export interface publicacionesguardadasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Publicacionesguardadas that matches the filter.
     * @param {publicacionesguardadasFindUniqueArgs} args - Arguments to find a Publicacionesguardadas
     * @example
     * // Get one Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends publicacionesguardadasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, publicacionesguardadasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'publicacionesguardadas'> extends True ? Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>> : Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T> | null, null>

    /**
     * Find one Publicacionesguardadas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {publicacionesguardadasFindUniqueOrThrowArgs} args - Arguments to find a Publicacionesguardadas
     * @example
     * // Get one Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends publicacionesguardadasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, publicacionesguardadasFindUniqueOrThrowArgs>
    ): Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>>

    /**
     * Find the first Publicacionesguardadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesguardadasFindFirstArgs} args - Arguments to find a Publicacionesguardadas
     * @example
     * // Get one Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends publicacionesguardadasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, publicacionesguardadasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'publicacionesguardadas'> extends True ? Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>> : Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T> | null, null>

    /**
     * Find the first Publicacionesguardadas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesguardadasFindFirstOrThrowArgs} args - Arguments to find a Publicacionesguardadas
     * @example
     * // Get one Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends publicacionesguardadasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, publicacionesguardadasFindFirstOrThrowArgs>
    ): Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>>

    /**
     * Find zero or more Publicacionesguardadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesguardadasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.findMany()
     * 
     * // Get first 10 Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.findMany({ take: 10 })
     * 
     * // Only select the `idpublicacionesguardadas`
     * const publicacionesguardadasWithIdpublicacionesguardadasOnly = await prisma.publicacionesguardadas.findMany({ select: { idpublicacionesguardadas: true } })
     * 
    **/
    findMany<T extends publicacionesguardadasFindManyArgs>(
      args?: SelectSubset<T, publicacionesguardadasFindManyArgs>
    ): Prisma.PrismaPromise<Array<publicacionesguardadasGetPayload<T>>>

    /**
     * Create a Publicacionesguardadas.
     * @param {publicacionesguardadasCreateArgs} args - Arguments to create a Publicacionesguardadas.
     * @example
     * // Create one Publicacionesguardadas
     * const Publicacionesguardadas = await prisma.publicacionesguardadas.create({
     *   data: {
     *     // ... data to create a Publicacionesguardadas
     *   }
     * })
     * 
    **/
    create<T extends publicacionesguardadasCreateArgs>(
      args: SelectSubset<T, publicacionesguardadasCreateArgs>
    ): Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>>

    /**
     * Create many Publicacionesguardadas.
     *     @param {publicacionesguardadasCreateManyArgs} args - Arguments to create many Publicacionesguardadas.
     *     @example
     *     // Create many Publicacionesguardadas
     *     const publicacionesguardadas = await prisma.publicacionesguardadas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends publicacionesguardadasCreateManyArgs>(
      args?: SelectSubset<T, publicacionesguardadasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publicacionesguardadas.
     * @param {publicacionesguardadasDeleteArgs} args - Arguments to delete one Publicacionesguardadas.
     * @example
     * // Delete one Publicacionesguardadas
     * const Publicacionesguardadas = await prisma.publicacionesguardadas.delete({
     *   where: {
     *     // ... filter to delete one Publicacionesguardadas
     *   }
     * })
     * 
    **/
    delete<T extends publicacionesguardadasDeleteArgs>(
      args: SelectSubset<T, publicacionesguardadasDeleteArgs>
    ): Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>>

    /**
     * Update one Publicacionesguardadas.
     * @param {publicacionesguardadasUpdateArgs} args - Arguments to update one Publicacionesguardadas.
     * @example
     * // Update one Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends publicacionesguardadasUpdateArgs>(
      args: SelectSubset<T, publicacionesguardadasUpdateArgs>
    ): Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>>

    /**
     * Delete zero or more Publicacionesguardadas.
     * @param {publicacionesguardadasDeleteManyArgs} args - Arguments to filter Publicacionesguardadas to delete.
     * @example
     * // Delete a few Publicacionesguardadas
     * const { count } = await prisma.publicacionesguardadas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends publicacionesguardadasDeleteManyArgs>(
      args?: SelectSubset<T, publicacionesguardadasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publicacionesguardadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesguardadasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends publicacionesguardadasUpdateManyArgs>(
      args: SelectSubset<T, publicacionesguardadasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publicacionesguardadas.
     * @param {publicacionesguardadasUpsertArgs} args - Arguments to update or create a Publicacionesguardadas.
     * @example
     * // Update or create a Publicacionesguardadas
     * const publicacionesguardadas = await prisma.publicacionesguardadas.upsert({
     *   create: {
     *     // ... data to create a Publicacionesguardadas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publicacionesguardadas we want to update
     *   }
     * })
    **/
    upsert<T extends publicacionesguardadasUpsertArgs>(
      args: SelectSubset<T, publicacionesguardadasUpsertArgs>
    ): Prisma__publicacionesguardadasClient<publicacionesguardadasGetPayload<T>>

    /**
     * Count the number of Publicacionesguardadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionesguardadasCountArgs} args - Arguments to filter Publicacionesguardadas to count.
     * @example
     * // Count the number of Publicacionesguardadas
     * const count = await prisma.publicacionesguardadas.count({
     *   where: {
     *     // ... the filter for the Publicacionesguardadas we want to count
     *   }
     * })
    **/
    count<T extends publicacionesguardadasCountArgs>(
      args?: Subset<T, publicacionesguardadasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicacionesguardadasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publicacionesguardadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacionesguardadasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicacionesguardadasAggregateArgs>(args: Subset<T, PublicacionesguardadasAggregateArgs>): Prisma.PrismaPromise<GetPublicacionesguardadasAggregateType<T>>

    /**
     * Group by Publicacionesguardadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacionesguardadasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicacionesguardadasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicacionesguardadasGroupByArgs['orderBy'] }
        : { orderBy?: PublicacionesguardadasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicacionesguardadasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicacionesguardadasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for publicacionesguardadas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__publicacionesguardadasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    publicaciones<T extends publicacionesArgs= {}>(args?: Subset<T, publicacionesArgs>): Prisma__publicacionesClient<publicacionesGetPayload<T> | Null>;

    usuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * publicacionesguardadas base type for findUnique actions
   */
  export type publicacionesguardadasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * Filter, which publicacionesguardadas to fetch.
     */
    where: publicacionesguardadasWhereUniqueInput
  }

  /**
   * publicacionesguardadas findUnique
   */
  export interface publicacionesguardadasFindUniqueArgs extends publicacionesguardadasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicacionesguardadas findUniqueOrThrow
   */
  export type publicacionesguardadasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * Filter, which publicacionesguardadas to fetch.
     */
    where: publicacionesguardadasWhereUniqueInput
  }


  /**
   * publicacionesguardadas base type for findFirst actions
   */
  export type publicacionesguardadasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * Filter, which publicacionesguardadas to fetch.
     */
    where?: publicacionesguardadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionesguardadas to fetch.
     */
    orderBy?: Enumerable<publicacionesguardadasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicacionesguardadas.
     */
    cursor?: publicacionesguardadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionesguardadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionesguardadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicacionesguardadas.
     */
    distinct?: Enumerable<PublicacionesguardadasScalarFieldEnum>
  }

  /**
   * publicacionesguardadas findFirst
   */
  export interface publicacionesguardadasFindFirstArgs extends publicacionesguardadasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicacionesguardadas findFirstOrThrow
   */
  export type publicacionesguardadasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * Filter, which publicacionesguardadas to fetch.
     */
    where?: publicacionesguardadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionesguardadas to fetch.
     */
    orderBy?: Enumerable<publicacionesguardadasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicacionesguardadas.
     */
    cursor?: publicacionesguardadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionesguardadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionesguardadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicacionesguardadas.
     */
    distinct?: Enumerable<PublicacionesguardadasScalarFieldEnum>
  }


  /**
   * publicacionesguardadas findMany
   */
  export type publicacionesguardadasFindManyArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * Filter, which publicacionesguardadas to fetch.
     */
    where?: publicacionesguardadasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionesguardadas to fetch.
     */
    orderBy?: Enumerable<publicacionesguardadasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publicacionesguardadas.
     */
    cursor?: publicacionesguardadasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionesguardadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionesguardadas.
     */
    skip?: number
    distinct?: Enumerable<PublicacionesguardadasScalarFieldEnum>
  }


  /**
   * publicacionesguardadas create
   */
  export type publicacionesguardadasCreateArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * The data needed to create a publicacionesguardadas.
     */
    data: XOR<publicacionesguardadasCreateInput, publicacionesguardadasUncheckedCreateInput>
  }


  /**
   * publicacionesguardadas createMany
   */
  export type publicacionesguardadasCreateManyArgs = {
    /**
     * The data used to create many publicacionesguardadas.
     */
    data: Enumerable<publicacionesguardadasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * publicacionesguardadas update
   */
  export type publicacionesguardadasUpdateArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * The data needed to update a publicacionesguardadas.
     */
    data: XOR<publicacionesguardadasUpdateInput, publicacionesguardadasUncheckedUpdateInput>
    /**
     * Choose, which publicacionesguardadas to update.
     */
    where: publicacionesguardadasWhereUniqueInput
  }


  /**
   * publicacionesguardadas updateMany
   */
  export type publicacionesguardadasUpdateManyArgs = {
    /**
     * The data used to update publicacionesguardadas.
     */
    data: XOR<publicacionesguardadasUpdateManyMutationInput, publicacionesguardadasUncheckedUpdateManyInput>
    /**
     * Filter which publicacionesguardadas to update
     */
    where?: publicacionesguardadasWhereInput
  }


  /**
   * publicacionesguardadas upsert
   */
  export type publicacionesguardadasUpsertArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * The filter to search for the publicacionesguardadas to update in case it exists.
     */
    where: publicacionesguardadasWhereUniqueInput
    /**
     * In case the publicacionesguardadas found by the `where` argument doesn't exist, create a new publicacionesguardadas with this data.
     */
    create: XOR<publicacionesguardadasCreateInput, publicacionesguardadasUncheckedCreateInput>
    /**
     * In case the publicacionesguardadas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publicacionesguardadasUpdateInput, publicacionesguardadasUncheckedUpdateInput>
  }


  /**
   * publicacionesguardadas delete
   */
  export type publicacionesguardadasDeleteArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    /**
     * Filter which publicacionesguardadas to delete.
     */
    where: publicacionesguardadasWhereUniqueInput
  }


  /**
   * publicacionesguardadas deleteMany
   */
  export type publicacionesguardadasDeleteManyArgs = {
    /**
     * Filter which publicacionesguardadas to delete
     */
    where?: publicacionesguardadasWhereInput
  }


  /**
   * publicacionesguardadas without action
   */
  export type publicacionesguardadasArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
  }



  /**
   * Model publicacionestablero
   */


  export type AggregatePublicacionestablero = {
    _count: PublicacionestableroCountAggregateOutputType | null
    _avg: PublicacionestableroAvgAggregateOutputType | null
    _sum: PublicacionestableroSumAggregateOutputType | null
    _min: PublicacionestableroMinAggregateOutputType | null
    _max: PublicacionestableroMaxAggregateOutputType | null
  }

  export type PublicacionestableroAvgAggregateOutputType = {
    idpublicacionestablero: number | null
    idtablero: number | null
    idpublicacion: number | null
  }

  export type PublicacionestableroSumAggregateOutputType = {
    idpublicacionestablero: number | null
    idtablero: number | null
    idpublicacion: number | null
  }

  export type PublicacionestableroMinAggregateOutputType = {
    idpublicacionestablero: number | null
    idtablero: number | null
    idpublicacion: number | null
  }

  export type PublicacionestableroMaxAggregateOutputType = {
    idpublicacionestablero: number | null
    idtablero: number | null
    idpublicacion: number | null
  }

  export type PublicacionestableroCountAggregateOutputType = {
    idpublicacionestablero: number
    idtablero: number
    idpublicacion: number
    _all: number
  }


  export type PublicacionestableroAvgAggregateInputType = {
    idpublicacionestablero?: true
    idtablero?: true
    idpublicacion?: true
  }

  export type PublicacionestableroSumAggregateInputType = {
    idpublicacionestablero?: true
    idtablero?: true
    idpublicacion?: true
  }

  export type PublicacionestableroMinAggregateInputType = {
    idpublicacionestablero?: true
    idtablero?: true
    idpublicacion?: true
  }

  export type PublicacionestableroMaxAggregateInputType = {
    idpublicacionestablero?: true
    idtablero?: true
    idpublicacion?: true
  }

  export type PublicacionestableroCountAggregateInputType = {
    idpublicacionestablero?: true
    idtablero?: true
    idpublicacion?: true
    _all?: true
  }

  export type PublicacionestableroAggregateArgs = {
    /**
     * Filter which publicacionestablero to aggregate.
     */
    where?: publicacionestableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionestableros to fetch.
     */
    orderBy?: Enumerable<publicacionestableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publicacionestableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionestableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionestableros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publicacionestableros
    **/
    _count?: true | PublicacionestableroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicacionestableroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicacionestableroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicacionestableroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicacionestableroMaxAggregateInputType
  }

  export type GetPublicacionestableroAggregateType<T extends PublicacionestableroAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicacionestablero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicacionestablero[P]>
      : GetScalarType<T[P], AggregatePublicacionestablero[P]>
  }




  export type PublicacionestableroGroupByArgs = {
    where?: publicacionestableroWhereInput
    orderBy?: Enumerable<publicacionestableroOrderByWithAggregationInput>
    by: PublicacionestableroScalarFieldEnum[]
    having?: publicacionestableroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicacionestableroCountAggregateInputType | true
    _avg?: PublicacionestableroAvgAggregateInputType
    _sum?: PublicacionestableroSumAggregateInputType
    _min?: PublicacionestableroMinAggregateInputType
    _max?: PublicacionestableroMaxAggregateInputType
  }


  export type PublicacionestableroGroupByOutputType = {
    idpublicacionestablero: number
    idtablero: number
    idpublicacion: number
    _count: PublicacionestableroCountAggregateOutputType | null
    _avg: PublicacionestableroAvgAggregateOutputType | null
    _sum: PublicacionestableroSumAggregateOutputType | null
    _min: PublicacionestableroMinAggregateOutputType | null
    _max: PublicacionestableroMaxAggregateOutputType | null
  }

  type GetPublicacionestableroGroupByPayload<T extends PublicacionestableroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PublicacionestableroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicacionestableroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicacionestableroGroupByOutputType[P]>
            : GetScalarType<T[P], PublicacionestableroGroupByOutputType[P]>
        }
      >
    >


  export type publicacionestableroSelect = {
    idpublicacionestablero?: boolean
    idtablero?: boolean
    idpublicacion?: boolean
    tablero?: boolean | tableroArgs
    publicaciones?: boolean | publicacionesArgs
  }


  export type publicacionestableroInclude = {
    tablero?: boolean | tableroArgs
    publicaciones?: boolean | publicacionesArgs
  }

  export type publicacionestableroGetPayload<S extends boolean | null | undefined | publicacionestableroArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? publicacionestablero :
    S extends undefined ? never :
    S extends { include: any } & (publicacionestableroArgs | publicacionestableroFindManyArgs)
    ? publicacionestablero  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tablero' ? tableroGetPayload<S['include'][P]> :
        P extends 'publicaciones' ? publicacionesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (publicacionestableroArgs | publicacionestableroFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tablero' ? tableroGetPayload<S['select'][P]> :
        P extends 'publicaciones' ? publicacionesGetPayload<S['select'][P]> :  P extends keyof publicacionestablero ? publicacionestablero[P] : never
  } 
      : publicacionestablero


  type publicacionestableroCountArgs = 
    Omit<publicacionestableroFindManyArgs, 'select' | 'include'> & {
      select?: PublicacionestableroCountAggregateInputType | true
    }

  export interface publicacionestableroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Publicacionestablero that matches the filter.
     * @param {publicacionestableroFindUniqueArgs} args - Arguments to find a Publicacionestablero
     * @example
     * // Get one Publicacionestablero
     * const publicacionestablero = await prisma.publicacionestablero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends publicacionestableroFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, publicacionestableroFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'publicacionestablero'> extends True ? Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>> : Prisma__publicacionestableroClient<publicacionestableroGetPayload<T> | null, null>

    /**
     * Find one Publicacionestablero that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {publicacionestableroFindUniqueOrThrowArgs} args - Arguments to find a Publicacionestablero
     * @example
     * // Get one Publicacionestablero
     * const publicacionestablero = await prisma.publicacionestablero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends publicacionestableroFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, publicacionestableroFindUniqueOrThrowArgs>
    ): Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>>

    /**
     * Find the first Publicacionestablero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionestableroFindFirstArgs} args - Arguments to find a Publicacionestablero
     * @example
     * // Get one Publicacionestablero
     * const publicacionestablero = await prisma.publicacionestablero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends publicacionestableroFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, publicacionestableroFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'publicacionestablero'> extends True ? Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>> : Prisma__publicacionestableroClient<publicacionestableroGetPayload<T> | null, null>

    /**
     * Find the first Publicacionestablero that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionestableroFindFirstOrThrowArgs} args - Arguments to find a Publicacionestablero
     * @example
     * // Get one Publicacionestablero
     * const publicacionestablero = await prisma.publicacionestablero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends publicacionestableroFindFirstOrThrowArgs>(
      args?: SelectSubset<T, publicacionestableroFindFirstOrThrowArgs>
    ): Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>>

    /**
     * Find zero or more Publicacionestableros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionestableroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publicacionestableros
     * const publicacionestableros = await prisma.publicacionestablero.findMany()
     * 
     * // Get first 10 Publicacionestableros
     * const publicacionestableros = await prisma.publicacionestablero.findMany({ take: 10 })
     * 
     * // Only select the `idpublicacionestablero`
     * const publicacionestableroWithIdpublicacionestableroOnly = await prisma.publicacionestablero.findMany({ select: { idpublicacionestablero: true } })
     * 
    **/
    findMany<T extends publicacionestableroFindManyArgs>(
      args?: SelectSubset<T, publicacionestableroFindManyArgs>
    ): Prisma.PrismaPromise<Array<publicacionestableroGetPayload<T>>>

    /**
     * Create a Publicacionestablero.
     * @param {publicacionestableroCreateArgs} args - Arguments to create a Publicacionestablero.
     * @example
     * // Create one Publicacionestablero
     * const Publicacionestablero = await prisma.publicacionestablero.create({
     *   data: {
     *     // ... data to create a Publicacionestablero
     *   }
     * })
     * 
    **/
    create<T extends publicacionestableroCreateArgs>(
      args: SelectSubset<T, publicacionestableroCreateArgs>
    ): Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>>

    /**
     * Create many Publicacionestableros.
     *     @param {publicacionestableroCreateManyArgs} args - Arguments to create many Publicacionestableros.
     *     @example
     *     // Create many Publicacionestableros
     *     const publicacionestablero = await prisma.publicacionestablero.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends publicacionestableroCreateManyArgs>(
      args?: SelectSubset<T, publicacionestableroCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publicacionestablero.
     * @param {publicacionestableroDeleteArgs} args - Arguments to delete one Publicacionestablero.
     * @example
     * // Delete one Publicacionestablero
     * const Publicacionestablero = await prisma.publicacionestablero.delete({
     *   where: {
     *     // ... filter to delete one Publicacionestablero
     *   }
     * })
     * 
    **/
    delete<T extends publicacionestableroDeleteArgs>(
      args: SelectSubset<T, publicacionestableroDeleteArgs>
    ): Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>>

    /**
     * Update one Publicacionestablero.
     * @param {publicacionestableroUpdateArgs} args - Arguments to update one Publicacionestablero.
     * @example
     * // Update one Publicacionestablero
     * const publicacionestablero = await prisma.publicacionestablero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends publicacionestableroUpdateArgs>(
      args: SelectSubset<T, publicacionestableroUpdateArgs>
    ): Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>>

    /**
     * Delete zero or more Publicacionestableros.
     * @param {publicacionestableroDeleteManyArgs} args - Arguments to filter Publicacionestableros to delete.
     * @example
     * // Delete a few Publicacionestableros
     * const { count } = await prisma.publicacionestablero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends publicacionestableroDeleteManyArgs>(
      args?: SelectSubset<T, publicacionestableroDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publicacionestableros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionestableroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publicacionestableros
     * const publicacionestablero = await prisma.publicacionestablero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends publicacionestableroUpdateManyArgs>(
      args: SelectSubset<T, publicacionestableroUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publicacionestablero.
     * @param {publicacionestableroUpsertArgs} args - Arguments to update or create a Publicacionestablero.
     * @example
     * // Update or create a Publicacionestablero
     * const publicacionestablero = await prisma.publicacionestablero.upsert({
     *   create: {
     *     // ... data to create a Publicacionestablero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publicacionestablero we want to update
     *   }
     * })
    **/
    upsert<T extends publicacionestableroUpsertArgs>(
      args: SelectSubset<T, publicacionestableroUpsertArgs>
    ): Prisma__publicacionestableroClient<publicacionestableroGetPayload<T>>

    /**
     * Count the number of Publicacionestableros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicacionestableroCountArgs} args - Arguments to filter Publicacionestableros to count.
     * @example
     * // Count the number of Publicacionestableros
     * const count = await prisma.publicacionestablero.count({
     *   where: {
     *     // ... the filter for the Publicacionestableros we want to count
     *   }
     * })
    **/
    count<T extends publicacionestableroCountArgs>(
      args?: Subset<T, publicacionestableroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicacionestableroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publicacionestablero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacionestableroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicacionestableroAggregateArgs>(args: Subset<T, PublicacionestableroAggregateArgs>): Prisma.PrismaPromise<GetPublicacionestableroAggregateType<T>>

    /**
     * Group by Publicacionestablero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacionestableroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicacionestableroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicacionestableroGroupByArgs['orderBy'] }
        : { orderBy?: PublicacionestableroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicacionestableroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicacionestableroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for publicacionestablero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__publicacionestableroClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tablero<T extends tableroArgs= {}>(args?: Subset<T, tableroArgs>): Prisma__tableroClient<tableroGetPayload<T> | Null>;

    publicaciones<T extends publicacionesArgs= {}>(args?: Subset<T, publicacionesArgs>): Prisma__publicacionesClient<publicacionesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * publicacionestablero base type for findUnique actions
   */
  export type publicacionestableroFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * Filter, which publicacionestablero to fetch.
     */
    where: publicacionestableroWhereUniqueInput
  }

  /**
   * publicacionestablero findUnique
   */
  export interface publicacionestableroFindUniqueArgs extends publicacionestableroFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicacionestablero findUniqueOrThrow
   */
  export type publicacionestableroFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * Filter, which publicacionestablero to fetch.
     */
    where: publicacionestableroWhereUniqueInput
  }


  /**
   * publicacionestablero base type for findFirst actions
   */
  export type publicacionestableroFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * Filter, which publicacionestablero to fetch.
     */
    where?: publicacionestableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionestableros to fetch.
     */
    orderBy?: Enumerable<publicacionestableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicacionestableros.
     */
    cursor?: publicacionestableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionestableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionestableros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicacionestableros.
     */
    distinct?: Enumerable<PublicacionestableroScalarFieldEnum>
  }

  /**
   * publicacionestablero findFirst
   */
  export interface publicacionestableroFindFirstArgs extends publicacionestableroFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicacionestablero findFirstOrThrow
   */
  export type publicacionestableroFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * Filter, which publicacionestablero to fetch.
     */
    where?: publicacionestableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionestableros to fetch.
     */
    orderBy?: Enumerable<publicacionestableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicacionestableros.
     */
    cursor?: publicacionestableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionestableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionestableros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicacionestableros.
     */
    distinct?: Enumerable<PublicacionestableroScalarFieldEnum>
  }


  /**
   * publicacionestablero findMany
   */
  export type publicacionestableroFindManyArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * Filter, which publicacionestableros to fetch.
     */
    where?: publicacionestableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicacionestableros to fetch.
     */
    orderBy?: Enumerable<publicacionestableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publicacionestableros.
     */
    cursor?: publicacionestableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicacionestableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicacionestableros.
     */
    skip?: number
    distinct?: Enumerable<PublicacionestableroScalarFieldEnum>
  }


  /**
   * publicacionestablero create
   */
  export type publicacionestableroCreateArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * The data needed to create a publicacionestablero.
     */
    data: XOR<publicacionestableroCreateInput, publicacionestableroUncheckedCreateInput>
  }


  /**
   * publicacionestablero createMany
   */
  export type publicacionestableroCreateManyArgs = {
    /**
     * The data used to create many publicacionestableros.
     */
    data: Enumerable<publicacionestableroCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * publicacionestablero update
   */
  export type publicacionestableroUpdateArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * The data needed to update a publicacionestablero.
     */
    data: XOR<publicacionestableroUpdateInput, publicacionestableroUncheckedUpdateInput>
    /**
     * Choose, which publicacionestablero to update.
     */
    where: publicacionestableroWhereUniqueInput
  }


  /**
   * publicacionestablero updateMany
   */
  export type publicacionestableroUpdateManyArgs = {
    /**
     * The data used to update publicacionestableros.
     */
    data: XOR<publicacionestableroUpdateManyMutationInput, publicacionestableroUncheckedUpdateManyInput>
    /**
     * Filter which publicacionestableros to update
     */
    where?: publicacionestableroWhereInput
  }


  /**
   * publicacionestablero upsert
   */
  export type publicacionestableroUpsertArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * The filter to search for the publicacionestablero to update in case it exists.
     */
    where: publicacionestableroWhereUniqueInput
    /**
     * In case the publicacionestablero found by the `where` argument doesn't exist, create a new publicacionestablero with this data.
     */
    create: XOR<publicacionestableroCreateInput, publicacionestableroUncheckedCreateInput>
    /**
     * In case the publicacionestablero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publicacionestableroUpdateInput, publicacionestableroUncheckedUpdateInput>
  }


  /**
   * publicacionestablero delete
   */
  export type publicacionestableroDeleteArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    /**
     * Filter which publicacionestablero to delete.
     */
    where: publicacionestableroWhereUniqueInput
  }


  /**
   * publicacionestablero deleteMany
   */
  export type publicacionestableroDeleteManyArgs = {
    /**
     * Filter which publicacionestableros to delete
     */
    where?: publicacionestableroWhereInput
  }


  /**
   * publicacionestablero without action
   */
  export type publicacionestableroArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
  }



  /**
   * Model tablero
   */


  export type AggregateTablero = {
    _count: TableroCountAggregateOutputType | null
    _avg: TableroAvgAggregateOutputType | null
    _sum: TableroSumAggregateOutputType | null
    _min: TableroMinAggregateOutputType | null
    _max: TableroMaxAggregateOutputType | null
  }

  export type TableroAvgAggregateOutputType = {
    idtablero: number | null
    privacidad: number | null
    idusuario: number | null
  }

  export type TableroSumAggregateOutputType = {
    idtablero: number | null
    privacidad: number | null
    idusuario: number | null
  }

  export type TableroMinAggregateOutputType = {
    idtablero: number | null
    nombre: string | null
    privacidad: number | null
    idusuario: number | null
    imagen: Buffer | null
  }

  export type TableroMaxAggregateOutputType = {
    idtablero: number | null
    nombre: string | null
    privacidad: number | null
    idusuario: number | null
    imagen: Buffer | null
  }

  export type TableroCountAggregateOutputType = {
    idtablero: number
    nombre: number
    privacidad: number
    idusuario: number
    imagen: number
    _all: number
  }


  export type TableroAvgAggregateInputType = {
    idtablero?: true
    privacidad?: true
    idusuario?: true
  }

  export type TableroSumAggregateInputType = {
    idtablero?: true
    privacidad?: true
    idusuario?: true
  }

  export type TableroMinAggregateInputType = {
    idtablero?: true
    nombre?: true
    privacidad?: true
    idusuario?: true
    imagen?: true
  }

  export type TableroMaxAggregateInputType = {
    idtablero?: true
    nombre?: true
    privacidad?: true
    idusuario?: true
    imagen?: true
  }

  export type TableroCountAggregateInputType = {
    idtablero?: true
    nombre?: true
    privacidad?: true
    idusuario?: true
    imagen?: true
    _all?: true
  }

  export type TableroAggregateArgs = {
    /**
     * Filter which tablero to aggregate.
     */
    where?: tableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tableros to fetch.
     */
    orderBy?: Enumerable<tableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tableros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tableros
    **/
    _count?: true | TableroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableroMaxAggregateInputType
  }

  export type GetTableroAggregateType<T extends TableroAggregateArgs> = {
        [P in keyof T & keyof AggregateTablero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTablero[P]>
      : GetScalarType<T[P], AggregateTablero[P]>
  }




  export type TableroGroupByArgs = {
    where?: tableroWhereInput
    orderBy?: Enumerable<tableroOrderByWithAggregationInput>
    by: TableroScalarFieldEnum[]
    having?: tableroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableroCountAggregateInputType | true
    _avg?: TableroAvgAggregateInputType
    _sum?: TableroSumAggregateInputType
    _min?: TableroMinAggregateInputType
    _max?: TableroMaxAggregateInputType
  }


  export type TableroGroupByOutputType = {
    idtablero: number
    nombre: string
    privacidad: number
    idusuario: number
    imagen: Buffer | null
    _count: TableroCountAggregateOutputType | null
    _avg: TableroAvgAggregateOutputType | null
    _sum: TableroSumAggregateOutputType | null
    _min: TableroMinAggregateOutputType | null
    _max: TableroMaxAggregateOutputType | null
  }

  type GetTableroGroupByPayload<T extends TableroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TableroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableroGroupByOutputType[P]>
            : GetScalarType<T[P], TableroGroupByOutputType[P]>
        }
      >
    >


  export type tableroSelect = {
    idtablero?: boolean
    nombre?: boolean
    privacidad?: boolean
    idusuario?: boolean
    imagen?: boolean
    publicacionestablero?: boolean | tablero$publicacionestableroArgs
    usuario?: boolean | usuarioArgs
    _count?: boolean | TableroCountOutputTypeArgs
  }


  export type tableroInclude = {
    publicacionestablero?: boolean | tablero$publicacionestableroArgs
    usuario?: boolean | usuarioArgs
    _count?: boolean | TableroCountOutputTypeArgs
  }

  export type tableroGetPayload<S extends boolean | null | undefined | tableroArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tablero :
    S extends undefined ? never :
    S extends { include: any } & (tableroArgs | tableroFindManyArgs)
    ? tablero  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'publicacionestablero' ? Array < publicacionestableroGetPayload<S['include'][P]>>  :
        P extends 'usuario' ? usuarioGetPayload<S['include'][P]> :
        P extends '_count' ? TableroCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tableroArgs | tableroFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'publicacionestablero' ? Array < publicacionestableroGetPayload<S['select'][P]>>  :
        P extends 'usuario' ? usuarioGetPayload<S['select'][P]> :
        P extends '_count' ? TableroCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tablero ? tablero[P] : never
  } 
      : tablero


  type tableroCountArgs = 
    Omit<tableroFindManyArgs, 'select' | 'include'> & {
      select?: TableroCountAggregateInputType | true
    }

  export interface tableroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tablero that matches the filter.
     * @param {tableroFindUniqueArgs} args - Arguments to find a Tablero
     * @example
     * // Get one Tablero
     * const tablero = await prisma.tablero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tableroFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tableroFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tablero'> extends True ? Prisma__tableroClient<tableroGetPayload<T>> : Prisma__tableroClient<tableroGetPayload<T> | null, null>

    /**
     * Find one Tablero that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tableroFindUniqueOrThrowArgs} args - Arguments to find a Tablero
     * @example
     * // Get one Tablero
     * const tablero = await prisma.tablero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tableroFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tableroFindUniqueOrThrowArgs>
    ): Prisma__tableroClient<tableroGetPayload<T>>

    /**
     * Find the first Tablero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableroFindFirstArgs} args - Arguments to find a Tablero
     * @example
     * // Get one Tablero
     * const tablero = await prisma.tablero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tableroFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tableroFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tablero'> extends True ? Prisma__tableroClient<tableroGetPayload<T>> : Prisma__tableroClient<tableroGetPayload<T> | null, null>

    /**
     * Find the first Tablero that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableroFindFirstOrThrowArgs} args - Arguments to find a Tablero
     * @example
     * // Get one Tablero
     * const tablero = await prisma.tablero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tableroFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tableroFindFirstOrThrowArgs>
    ): Prisma__tableroClient<tableroGetPayload<T>>

    /**
     * Find zero or more Tableros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tableros
     * const tableros = await prisma.tablero.findMany()
     * 
     * // Get first 10 Tableros
     * const tableros = await prisma.tablero.findMany({ take: 10 })
     * 
     * // Only select the `idtablero`
     * const tableroWithIdtableroOnly = await prisma.tablero.findMany({ select: { idtablero: true } })
     * 
    **/
    findMany<T extends tableroFindManyArgs>(
      args?: SelectSubset<T, tableroFindManyArgs>
    ): Prisma.PrismaPromise<Array<tableroGetPayload<T>>>

    /**
     * Create a Tablero.
     * @param {tableroCreateArgs} args - Arguments to create a Tablero.
     * @example
     * // Create one Tablero
     * const Tablero = await prisma.tablero.create({
     *   data: {
     *     // ... data to create a Tablero
     *   }
     * })
     * 
    **/
    create<T extends tableroCreateArgs>(
      args: SelectSubset<T, tableroCreateArgs>
    ): Prisma__tableroClient<tableroGetPayload<T>>

    /**
     * Create many Tableros.
     *     @param {tableroCreateManyArgs} args - Arguments to create many Tableros.
     *     @example
     *     // Create many Tableros
     *     const tablero = await prisma.tablero.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tableroCreateManyArgs>(
      args?: SelectSubset<T, tableroCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tablero.
     * @param {tableroDeleteArgs} args - Arguments to delete one Tablero.
     * @example
     * // Delete one Tablero
     * const Tablero = await prisma.tablero.delete({
     *   where: {
     *     // ... filter to delete one Tablero
     *   }
     * })
     * 
    **/
    delete<T extends tableroDeleteArgs>(
      args: SelectSubset<T, tableroDeleteArgs>
    ): Prisma__tableroClient<tableroGetPayload<T>>

    /**
     * Update one Tablero.
     * @param {tableroUpdateArgs} args - Arguments to update one Tablero.
     * @example
     * // Update one Tablero
     * const tablero = await prisma.tablero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tableroUpdateArgs>(
      args: SelectSubset<T, tableroUpdateArgs>
    ): Prisma__tableroClient<tableroGetPayload<T>>

    /**
     * Delete zero or more Tableros.
     * @param {tableroDeleteManyArgs} args - Arguments to filter Tableros to delete.
     * @example
     * // Delete a few Tableros
     * const { count } = await prisma.tablero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tableroDeleteManyArgs>(
      args?: SelectSubset<T, tableroDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tableros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tableros
     * const tablero = await prisma.tablero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tableroUpdateManyArgs>(
      args: SelectSubset<T, tableroUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tablero.
     * @param {tableroUpsertArgs} args - Arguments to update or create a Tablero.
     * @example
     * // Update or create a Tablero
     * const tablero = await prisma.tablero.upsert({
     *   create: {
     *     // ... data to create a Tablero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tablero we want to update
     *   }
     * })
    **/
    upsert<T extends tableroUpsertArgs>(
      args: SelectSubset<T, tableroUpsertArgs>
    ): Prisma__tableroClient<tableroGetPayload<T>>

    /**
     * Count the number of Tableros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tableroCountArgs} args - Arguments to filter Tableros to count.
     * @example
     * // Count the number of Tableros
     * const count = await prisma.tablero.count({
     *   where: {
     *     // ... the filter for the Tableros we want to count
     *   }
     * })
    **/
    count<T extends tableroCountArgs>(
      args?: Subset<T, tableroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tablero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableroAggregateArgs>(args: Subset<T, TableroAggregateArgs>): Prisma.PrismaPromise<GetTableroAggregateType<T>>

    /**
     * Group by Tablero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableroGroupByArgs['orderBy'] }
        : { orderBy?: TableroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tablero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tableroClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    publicacionestablero<T extends tablero$publicacionestableroArgs= {}>(args?: Subset<T, tablero$publicacionestableroArgs>): Prisma.PrismaPromise<Array<publicacionestableroGetPayload<T>>| Null>;

    usuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tablero base type for findUnique actions
   */
  export type tableroFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * Filter, which tablero to fetch.
     */
    where: tableroWhereUniqueInput
  }

  /**
   * tablero findUnique
   */
  export interface tableroFindUniqueArgs extends tableroFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablero findUniqueOrThrow
   */
  export type tableroFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * Filter, which tablero to fetch.
     */
    where: tableroWhereUniqueInput
  }


  /**
   * tablero base type for findFirst actions
   */
  export type tableroFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * Filter, which tablero to fetch.
     */
    where?: tableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tableros to fetch.
     */
    orderBy?: Enumerable<tableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tableros.
     */
    cursor?: tableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tableros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tableros.
     */
    distinct?: Enumerable<TableroScalarFieldEnum>
  }

  /**
   * tablero findFirst
   */
  export interface tableroFindFirstArgs extends tableroFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablero findFirstOrThrow
   */
  export type tableroFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * Filter, which tablero to fetch.
     */
    where?: tableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tableros to fetch.
     */
    orderBy?: Enumerable<tableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tableros.
     */
    cursor?: tableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tableros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tableros.
     */
    distinct?: Enumerable<TableroScalarFieldEnum>
  }


  /**
   * tablero findMany
   */
  export type tableroFindManyArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * Filter, which tableros to fetch.
     */
    where?: tableroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tableros to fetch.
     */
    orderBy?: Enumerable<tableroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tableros.
     */
    cursor?: tableroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tableros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tableros.
     */
    skip?: number
    distinct?: Enumerable<TableroScalarFieldEnum>
  }


  /**
   * tablero create
   */
  export type tableroCreateArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * The data needed to create a tablero.
     */
    data: XOR<tableroCreateInput, tableroUncheckedCreateInput>
  }


  /**
   * tablero createMany
   */
  export type tableroCreateManyArgs = {
    /**
     * The data used to create many tableros.
     */
    data: Enumerable<tableroCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tablero update
   */
  export type tableroUpdateArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * The data needed to update a tablero.
     */
    data: XOR<tableroUpdateInput, tableroUncheckedUpdateInput>
    /**
     * Choose, which tablero to update.
     */
    where: tableroWhereUniqueInput
  }


  /**
   * tablero updateMany
   */
  export type tableroUpdateManyArgs = {
    /**
     * The data used to update tableros.
     */
    data: XOR<tableroUpdateManyMutationInput, tableroUncheckedUpdateManyInput>
    /**
     * Filter which tableros to update
     */
    where?: tableroWhereInput
  }


  /**
   * tablero upsert
   */
  export type tableroUpsertArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * The filter to search for the tablero to update in case it exists.
     */
    where: tableroWhereUniqueInput
    /**
     * In case the tablero found by the `where` argument doesn't exist, create a new tablero with this data.
     */
    create: XOR<tableroCreateInput, tableroUncheckedCreateInput>
    /**
     * In case the tablero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tableroUpdateInput, tableroUncheckedUpdateInput>
  }


  /**
   * tablero delete
   */
  export type tableroDeleteArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    /**
     * Filter which tablero to delete.
     */
    where: tableroWhereUniqueInput
  }


  /**
   * tablero deleteMany
   */
  export type tableroDeleteManyArgs = {
    /**
     * Filter which tableros to delete
     */
    where?: tableroWhereInput
  }


  /**
   * tablero.publicacionestablero
   */
  export type tablero$publicacionestableroArgs = {
    /**
     * Select specific fields to fetch from the publicacionestablero
     */
    select?: publicacionestableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionestableroInclude | null
    where?: publicacionestableroWhereInput
    orderBy?: Enumerable<publicacionestableroOrderByWithRelationInput>
    cursor?: publicacionestableroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublicacionestableroScalarFieldEnum>
  }


  /**
   * tablero without action
   */
  export type tableroArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
  }



  /**
   * Model usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idusuario: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    idusuario: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    idusuario: number | null
    username: string | null
    email: string | null
    userpassword: string | null
    fotoperfil: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    idusuario: number | null
    username: string | null
    email: string | null
    userpassword: string | null
    fotoperfil: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    idusuario: number
    username: number
    email: number
    userpassword: number
    fotoperfil: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idusuario?: true
  }

  export type UsuarioSumAggregateInputType = {
    idusuario?: true
  }

  export type UsuarioMinAggregateInputType = {
    idusuario?: true
    username?: true
    email?: true
    userpassword?: true
    fotoperfil?: true
  }

  export type UsuarioMaxAggregateInputType = {
    idusuario?: true
    username?: true
    email?: true
    userpassword?: true
    fotoperfil?: true
  }

  export type UsuarioCountAggregateInputType = {
    idusuario?: true
    username?: true
    email?: true
    userpassword?: true
    fotoperfil?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: usuarioWhereInput
    orderBy?: Enumerable<usuarioOrderByWithAggregationInput>
    by: UsuarioScalarFieldEnum[]
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    idusuario: number
    username: string
    email: string
    userpassword: string | null
    fotoperfil: string | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect = {
    idusuario?: boolean
    username?: boolean
    email?: boolean
    userpassword?: boolean
    fotoperfil?: boolean
    comentarios?: boolean | usuario$comentariosArgs
    publicaciones?: boolean | usuario$publicacionesArgs
    publicacionesguardadas?: boolean | usuario$publicacionesguardadasArgs
    tablero?: boolean | usuario$tableroArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }


  export type usuarioInclude = {
    comentarios?: boolean | usuario$comentariosArgs
    publicaciones?: boolean | usuario$publicacionesArgs
    publicacionesguardadas?: boolean | usuario$publicacionesguardadasArgs
    tablero?: boolean | usuario$tableroArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type usuarioGetPayload<S extends boolean | null | undefined | usuarioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario :
    S extends undefined ? never :
    S extends { include: any } & (usuarioArgs | usuarioFindManyArgs)
    ? usuario  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'comentarios' ? Array < comentariosGetPayload<S['include'][P]>>  :
        P extends 'publicaciones' ? Array < publicacionesGetPayload<S['include'][P]>>  :
        P extends 'publicacionesguardadas' ? Array < publicacionesguardadasGetPayload<S['include'][P]>>  :
        P extends 'tablero' ? Array < tableroGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (usuarioArgs | usuarioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'comentarios' ? Array < comentariosGetPayload<S['select'][P]>>  :
        P extends 'publicaciones' ? Array < publicacionesGetPayload<S['select'][P]>>  :
        P extends 'publicacionesguardadas' ? Array < publicacionesguardadasGetPayload<S['select'][P]>>  :
        P extends 'tablero' ? Array < tableroGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof usuario ? usuario[P] : never
  } 
      : usuario


  type usuarioCountArgs = 
    Omit<usuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindUniqueOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `idusuario`
     * const usuarioWithIdusuarioOnly = await prisma.usuario.findMany({ select: { idusuario: true } })
     * 
    **/
    findMany<T extends usuarioFindManyArgs>(
      args?: SelectSubset<T, usuarioFindManyArgs>
    ): Prisma.PrismaPromise<Array<usuarioGetPayload<T>>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends usuarioCreateArgs>(
      args: SelectSubset<T, usuarioCreateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Create many Usuarios.
     *     @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuarioCreateManyArgs>(
      args?: SelectSubset<T, usuarioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends usuarioDeleteArgs>(
      args: SelectSubset<T, usuarioDeleteArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuarioUpdateArgs>(
      args: SelectSubset<T, usuarioUpdateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuarioDeleteManyArgs>(
      args?: SelectSubset<T, usuarioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuarioUpdateManyArgs>(
      args: SelectSubset<T, usuarioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends usuarioUpsertArgs>(
      args: SelectSubset<T, usuarioUpsertArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuarioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comentarios<T extends usuario$comentariosArgs= {}>(args?: Subset<T, usuario$comentariosArgs>): Prisma.PrismaPromise<Array<comentariosGetPayload<T>>| Null>;

    publicaciones<T extends usuario$publicacionesArgs= {}>(args?: Subset<T, usuario$publicacionesArgs>): Prisma.PrismaPromise<Array<publicacionesGetPayload<T>>| Null>;

    publicacionesguardadas<T extends usuario$publicacionesguardadasArgs= {}>(args?: Subset<T, usuario$publicacionesguardadasArgs>): Prisma.PrismaPromise<Array<publicacionesguardadasGetPayload<T>>| Null>;

    tablero<T extends usuario$tableroArgs= {}>(args?: Subset<T, usuario$tableroArgs>): Prisma.PrismaPromise<Array<tableroGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario base type for findUnique actions
   */
  export type usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUnique
   */
  export interface usuarioFindUniqueArgs extends usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario base type for findFirst actions
   */
  export type usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * usuario findFirst
   */
  export interface usuarioFindFirstArgs extends usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario create
   */
  export type usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }


  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs = {
    /**
     * The data used to create many usuarios.
     */
    data: Enumerable<usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario update
   */
  export type usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
  }


  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }


  /**
   * usuario delete
   */
  export type usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
  }


  /**
   * usuario.comentarios
   */
  export type usuario$comentariosArgs = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentariosInclude | null
    where?: comentariosWhereInput
    orderBy?: Enumerable<comentariosOrderByWithRelationInput>
    cursor?: comentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ComentariosScalarFieldEnum>
  }


  /**
   * usuario.publicaciones
   */
  export type usuario$publicacionesArgs = {
    /**
     * Select specific fields to fetch from the publicaciones
     */
    select?: publicacionesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesInclude | null
    where?: publicacionesWhereInput
    orderBy?: Enumerable<publicacionesOrderByWithRelationInput>
    cursor?: publicacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublicacionesScalarFieldEnum>
  }


  /**
   * usuario.publicacionesguardadas
   */
  export type usuario$publicacionesguardadasArgs = {
    /**
     * Select specific fields to fetch from the publicacionesguardadas
     */
    select?: publicacionesguardadasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publicacionesguardadasInclude | null
    where?: publicacionesguardadasWhereInput
    orderBy?: Enumerable<publicacionesguardadasOrderByWithRelationInput>
    cursor?: publicacionesguardadasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublicacionesguardadasScalarFieldEnum>
  }


  /**
   * usuario.tablero
   */
  export type usuario$tableroArgs = {
    /**
     * Select specific fields to fetch from the tablero
     */
    select?: tableroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tableroInclude | null
    where?: tableroWhereInput
    orderBy?: Enumerable<tableroOrderByWithRelationInput>
    cursor?: tableroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TableroScalarFieldEnum>
  }


  /**
   * usuario without action
   */
  export type usuarioArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usuarioInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CategoriasScalarFieldEnum: {
    idcategorias: 'idcategorias',
    nombre: 'nombre',
    imagen: 'imagen'
  };

  export type CategoriasScalarFieldEnum = (typeof CategoriasScalarFieldEnum)[keyof typeof CategoriasScalarFieldEnum]


  export const ComentariosScalarFieldEnum: {
    idcomentarios: 'idcomentarios',
    descripcion: 'descripcion',
    fecha: 'fecha',
    idusuario: 'idusuario',
    idpublicacion: 'idpublicacion'
  };

  export type ComentariosScalarFieldEnum = (typeof ComentariosScalarFieldEnum)[keyof typeof ComentariosScalarFieldEnum]


  export const ImagenScalarFieldEnum: {
    idimagen: 'idimagen',
    imagen: 'imagen',
    idpublicacion: 'idpublicacion'
  };

  export type ImagenScalarFieldEnum = (typeof ImagenScalarFieldEnum)[keyof typeof ImagenScalarFieldEnum]


  export const PublicacionesScalarFieldEnum: {
    idpublicaciones: 'idpublicaciones',
    titulo: 'titulo',
    descripcion: 'descripcion',
    idcategoria: 'idcategoria',
    idusuario: 'idusuario'
  };

  export type PublicacionesScalarFieldEnum = (typeof PublicacionesScalarFieldEnum)[keyof typeof PublicacionesScalarFieldEnum]


  export const PublicacionesguardadasScalarFieldEnum: {
    idpublicacionesguardadas: 'idpublicacionesguardadas',
    idpublicacion: 'idpublicacion',
    idusuario: 'idusuario'
  };

  export type PublicacionesguardadasScalarFieldEnum = (typeof PublicacionesguardadasScalarFieldEnum)[keyof typeof PublicacionesguardadasScalarFieldEnum]


  export const PublicacionestableroScalarFieldEnum: {
    idpublicacionestablero: 'idpublicacionestablero',
    idtablero: 'idtablero',
    idpublicacion: 'idpublicacion'
  };

  export type PublicacionestableroScalarFieldEnum = (typeof PublicacionestableroScalarFieldEnum)[keyof typeof PublicacionestableroScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TableroScalarFieldEnum: {
    idtablero: 'idtablero',
    nombre: 'nombre',
    privacidad: 'privacidad',
    idusuario: 'idusuario',
    imagen: 'imagen'
  };

  export type TableroScalarFieldEnum = (typeof TableroScalarFieldEnum)[keyof typeof TableroScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    idusuario: 'idusuario',
    username: 'username',
    email: 'email',
    userpassword: 'userpassword',
    fotoperfil: 'fotoperfil'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type categoriasWhereInput = {
    AND?: Enumerable<categoriasWhereInput>
    OR?: Enumerable<categoriasWhereInput>
    NOT?: Enumerable<categoriasWhereInput>
    idcategorias?: IntFilter | number
    nombre?: StringFilter | string
    imagen?: BytesNullableFilter | Buffer | null
    publicaciones?: PublicacionesListRelationFilter
  }

  export type categoriasOrderByWithRelationInput = {
    idcategorias?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    publicaciones?: publicacionesOrderByRelationAggregateInput
  }

  export type categoriasWhereUniqueInput = {
    idcategorias?: number
  }

  export type categoriasOrderByWithAggregationInput = {
    idcategorias?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    _count?: categoriasCountOrderByAggregateInput
    _avg?: categoriasAvgOrderByAggregateInput
    _max?: categoriasMaxOrderByAggregateInput
    _min?: categoriasMinOrderByAggregateInput
    _sum?: categoriasSumOrderByAggregateInput
  }

  export type categoriasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categoriasScalarWhereWithAggregatesInput>
    OR?: Enumerable<categoriasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categoriasScalarWhereWithAggregatesInput>
    idcategorias?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    imagen?: BytesNullableWithAggregatesFilter | Buffer | null
  }

  export type comentariosWhereInput = {
    AND?: Enumerable<comentariosWhereInput>
    OR?: Enumerable<comentariosWhereInput>
    NOT?: Enumerable<comentariosWhereInput>
    idcomentarios?: IntFilter | number
    descripcion?: StringFilter | string
    fecha?: DateTimeFilter | Date | string
    idusuario?: IntFilter | number
    idpublicacion?: IntFilter | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    publicaciones?: XOR<PublicacionesRelationFilter, publicacionesWhereInput>
  }

  export type comentariosOrderByWithRelationInput = {
    idcomentarios?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    publicaciones?: publicacionesOrderByWithRelationInput
  }

  export type comentariosWhereUniqueInput = {
    idcomentarios?: number
  }

  export type comentariosOrderByWithAggregationInput = {
    idcomentarios?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
    _count?: comentariosCountOrderByAggregateInput
    _avg?: comentariosAvgOrderByAggregateInput
    _max?: comentariosMaxOrderByAggregateInput
    _min?: comentariosMinOrderByAggregateInput
    _sum?: comentariosSumOrderByAggregateInput
  }

  export type comentariosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<comentariosScalarWhereWithAggregatesInput>
    OR?: Enumerable<comentariosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<comentariosScalarWhereWithAggregatesInput>
    idcomentarios?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    fecha?: DateTimeWithAggregatesFilter | Date | string
    idusuario?: IntWithAggregatesFilter | number
    idpublicacion?: IntWithAggregatesFilter | number
  }

  export type imagenWhereInput = {
    AND?: Enumerable<imagenWhereInput>
    OR?: Enumerable<imagenWhereInput>
    NOT?: Enumerable<imagenWhereInput>
    idimagen?: IntFilter | number
    imagen?: BytesFilter | Buffer
    idpublicacion?: IntFilter | number
    publicaciones?: XOR<PublicacionesRelationFilter, publicacionesWhereInput>
  }

  export type imagenOrderByWithRelationInput = {
    idimagen?: SortOrder
    imagen?: SortOrder
    idpublicacion?: SortOrder
    publicaciones?: publicacionesOrderByWithRelationInput
  }

  export type imagenWhereUniqueInput = {
    idimagen?: number
  }

  export type imagenOrderByWithAggregationInput = {
    idimagen?: SortOrder
    imagen?: SortOrder
    idpublicacion?: SortOrder
    _count?: imagenCountOrderByAggregateInput
    _avg?: imagenAvgOrderByAggregateInput
    _max?: imagenMaxOrderByAggregateInput
    _min?: imagenMinOrderByAggregateInput
    _sum?: imagenSumOrderByAggregateInput
  }

  export type imagenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<imagenScalarWhereWithAggregatesInput>
    OR?: Enumerable<imagenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<imagenScalarWhereWithAggregatesInput>
    idimagen?: IntWithAggregatesFilter | number
    imagen?: BytesWithAggregatesFilter | Buffer
    idpublicacion?: IntWithAggregatesFilter | number
  }

  export type publicacionesWhereInput = {
    AND?: Enumerable<publicacionesWhereInput>
    OR?: Enumerable<publicacionesWhereInput>
    NOT?: Enumerable<publicacionesWhereInput>
    idpublicaciones?: IntFilter | number
    titulo?: StringFilter | string
    descripcion?: StringFilter | string
    idcategoria?: IntFilter | number
    idusuario?: IntFilter | number
    comentarios?: ComentariosListRelationFilter
    imagen?: ImagenListRelationFilter
    categorias?: XOR<CategoriasRelationFilter, categoriasWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    publicacionesguardadas?: PublicacionesguardadasListRelationFilter
    publicacionestablero?: PublicacionestableroListRelationFilter
  }

  export type publicacionesOrderByWithRelationInput = {
    idpublicaciones?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
    comentarios?: comentariosOrderByRelationAggregateInput
    imagen?: imagenOrderByRelationAggregateInput
    categorias?: categoriasOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    publicacionesguardadas?: publicacionesguardadasOrderByRelationAggregateInput
    publicacionestablero?: publicacionestableroOrderByRelationAggregateInput
  }

  export type publicacionesWhereUniqueInput = {
    idpublicaciones?: number
  }

  export type publicacionesOrderByWithAggregationInput = {
    idpublicaciones?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
    _count?: publicacionesCountOrderByAggregateInput
    _avg?: publicacionesAvgOrderByAggregateInput
    _max?: publicacionesMaxOrderByAggregateInput
    _min?: publicacionesMinOrderByAggregateInput
    _sum?: publicacionesSumOrderByAggregateInput
  }

  export type publicacionesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<publicacionesScalarWhereWithAggregatesInput>
    OR?: Enumerable<publicacionesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<publicacionesScalarWhereWithAggregatesInput>
    idpublicaciones?: IntWithAggregatesFilter | number
    titulo?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    idcategoria?: IntWithAggregatesFilter | number
    idusuario?: IntWithAggregatesFilter | number
  }

  export type publicacionesguardadasWhereInput = {
    AND?: Enumerable<publicacionesguardadasWhereInput>
    OR?: Enumerable<publicacionesguardadasWhereInput>
    NOT?: Enumerable<publicacionesguardadasWhereInput>
    idpublicacionesguardadas?: IntFilter | number
    idpublicacion?: IntFilter | number
    idusuario?: IntFilter | number
    publicaciones?: XOR<PublicacionesRelationFilter, publicacionesWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type publicacionesguardadasOrderByWithRelationInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
    publicaciones?: publicacionesOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type publicacionesguardadasWhereUniqueInput = {
    idpublicacionesguardadas?: number
  }

  export type publicacionesguardadasOrderByWithAggregationInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
    _count?: publicacionesguardadasCountOrderByAggregateInput
    _avg?: publicacionesguardadasAvgOrderByAggregateInput
    _max?: publicacionesguardadasMaxOrderByAggregateInput
    _min?: publicacionesguardadasMinOrderByAggregateInput
    _sum?: publicacionesguardadasSumOrderByAggregateInput
  }

  export type publicacionesguardadasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<publicacionesguardadasScalarWhereWithAggregatesInput>
    OR?: Enumerable<publicacionesguardadasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<publicacionesguardadasScalarWhereWithAggregatesInput>
    idpublicacionesguardadas?: IntWithAggregatesFilter | number
    idpublicacion?: IntWithAggregatesFilter | number
    idusuario?: IntWithAggregatesFilter | number
  }

  export type publicacionestableroWhereInput = {
    AND?: Enumerable<publicacionestableroWhereInput>
    OR?: Enumerable<publicacionestableroWhereInput>
    NOT?: Enumerable<publicacionestableroWhereInput>
    idpublicacionestablero?: IntFilter | number
    idtablero?: IntFilter | number
    idpublicacion?: IntFilter | number
    tablero?: XOR<TableroRelationFilter, tableroWhereInput>
    publicaciones?: XOR<PublicacionesRelationFilter, publicacionesWhereInput>
  }

  export type publicacionestableroOrderByWithRelationInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
    tablero?: tableroOrderByWithRelationInput
    publicaciones?: publicacionesOrderByWithRelationInput
  }

  export type publicacionestableroWhereUniqueInput = {
    idpublicacionestablero?: number
  }

  export type publicacionestableroOrderByWithAggregationInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
    _count?: publicacionestableroCountOrderByAggregateInput
    _avg?: publicacionestableroAvgOrderByAggregateInput
    _max?: publicacionestableroMaxOrderByAggregateInput
    _min?: publicacionestableroMinOrderByAggregateInput
    _sum?: publicacionestableroSumOrderByAggregateInput
  }

  export type publicacionestableroScalarWhereWithAggregatesInput = {
    AND?: Enumerable<publicacionestableroScalarWhereWithAggregatesInput>
    OR?: Enumerable<publicacionestableroScalarWhereWithAggregatesInput>
    NOT?: Enumerable<publicacionestableroScalarWhereWithAggregatesInput>
    idpublicacionestablero?: IntWithAggregatesFilter | number
    idtablero?: IntWithAggregatesFilter | number
    idpublicacion?: IntWithAggregatesFilter | number
  }

  export type tableroWhereInput = {
    AND?: Enumerable<tableroWhereInput>
    OR?: Enumerable<tableroWhereInput>
    NOT?: Enumerable<tableroWhereInput>
    idtablero?: IntFilter | number
    nombre?: StringFilter | string
    privacidad?: IntFilter | number
    idusuario?: IntFilter | number
    imagen?: BytesNullableFilter | Buffer | null
    publicacionestablero?: PublicacionestableroListRelationFilter
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type tableroOrderByWithRelationInput = {
    idtablero?: SortOrder
    nombre?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
    imagen?: SortOrder
    publicacionestablero?: publicacionestableroOrderByRelationAggregateInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type tableroWhereUniqueInput = {
    idtablero?: number
  }

  export type tableroOrderByWithAggregationInput = {
    idtablero?: SortOrder
    nombre?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
    imagen?: SortOrder
    _count?: tableroCountOrderByAggregateInput
    _avg?: tableroAvgOrderByAggregateInput
    _max?: tableroMaxOrderByAggregateInput
    _min?: tableroMinOrderByAggregateInput
    _sum?: tableroSumOrderByAggregateInput
  }

  export type tableroScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tableroScalarWhereWithAggregatesInput>
    OR?: Enumerable<tableroScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tableroScalarWhereWithAggregatesInput>
    idtablero?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    privacidad?: IntWithAggregatesFilter | number
    idusuario?: IntWithAggregatesFilter | number
    imagen?: BytesNullableWithAggregatesFilter | Buffer | null
  }

  export type usuarioWhereInput = {
    AND?: Enumerable<usuarioWhereInput>
    OR?: Enumerable<usuarioWhereInput>
    NOT?: Enumerable<usuarioWhereInput>
    idusuario?: IntFilter | number
    username?: StringFilter | string
    email?: StringFilter | string
    userpassword?: StringNullableFilter | string | null
    fotoperfil?: StringNullableFilter | string | null
    comentarios?: ComentariosListRelationFilter
    publicaciones?: PublicacionesListRelationFilter
    publicacionesguardadas?: PublicacionesguardadasListRelationFilter
    tablero?: TableroListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    idusuario?: SortOrder
    username?: SortOrder
    email?: SortOrder
    userpassword?: SortOrder
    fotoperfil?: SortOrder
    comentarios?: comentariosOrderByRelationAggregateInput
    publicaciones?: publicacionesOrderByRelationAggregateInput
    publicacionesguardadas?: publicacionesguardadasOrderByRelationAggregateInput
    tablero?: tableroOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = {
    idusuario?: number
  }

  export type usuarioOrderByWithAggregationInput = {
    idusuario?: SortOrder
    username?: SortOrder
    email?: SortOrder
    userpassword?: SortOrder
    fotoperfil?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    idusuario?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    userpassword?: StringNullableWithAggregatesFilter | string | null
    fotoperfil?: StringNullableWithAggregatesFilter | string | null
  }

  export type categoriasCreateInput = {
    nombre: string
    imagen?: Buffer | null
    publicaciones?: publicacionesCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUncheckedCreateInput = {
    idcategorias?: number
    nombre: string
    imagen?: Buffer | null
    publicaciones?: publicacionesUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    publicaciones?: publicacionesUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasUncheckedUpdateInput = {
    idcategorias?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    publicaciones?: publicacionesUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasCreateManyInput = {
    idcategorias?: number
    nombre: string
    imagen?: Buffer | null
  }

  export type categoriasUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type categoriasUncheckedUpdateManyInput = {
    idcategorias?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type comentariosCreateInput = {
    descripcion: string
    fecha: Date | string
    usuario: usuarioCreateNestedOneWithoutComentariosInput
    publicaciones: publicacionesCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateInput = {
    idcomentarios?: number
    descripcion: string
    fecha: Date | string
    idusuario: number
    idpublicacion: number
  }

  export type comentariosUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuarioUpdateOneRequiredWithoutComentariosNestedInput
    publicaciones?: publicacionesUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateInput = {
    idcomentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idusuario?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type comentariosCreateManyInput = {
    idcomentarios?: number
    descripcion: string
    fecha: Date | string
    idusuario: number
    idpublicacion: number
  }

  export type comentariosUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateManyInput = {
    idcomentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idusuario?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type imagenCreateInput = {
    imagen: Buffer
    publicaciones: publicacionesCreateNestedOneWithoutImagenInput
  }

  export type imagenUncheckedCreateInput = {
    idimagen?: number
    imagen: Buffer
    idpublicacion: number
  }

  export type imagenUpdateInput = {
    imagen?: BytesFieldUpdateOperationsInput | Buffer
    publicaciones?: publicacionesUpdateOneRequiredWithoutImagenNestedInput
  }

  export type imagenUncheckedUpdateInput = {
    idimagen?: IntFieldUpdateOperationsInput | number
    imagen?: BytesFieldUpdateOperationsInput | Buffer
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type imagenCreateManyInput = {
    idimagen?: number
    imagen: Buffer
    idpublicacion: number
  }

  export type imagenUpdateManyMutationInput = {
    imagen?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type imagenUncheckedUpdateManyInput = {
    idimagen?: IntFieldUpdateOperationsInput | number
    imagen?: BytesFieldUpdateOperationsInput | Buffer
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionesCreateInput = {
    titulo: string
    descripcion: string
    comentarios?: comentariosCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenCreateNestedManyWithoutPublicacionesInput
    categorias: categoriasCreateNestedOneWithoutPublicacionesInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
    comentarios?: comentariosUncheckedCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    comentarios?: comentariosUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUpdateManyWithoutPublicacionesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutPublicacionesNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    comentarios?: comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesCreateManyInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
  }

  export type publicacionesUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type publicacionesUncheckedUpdateManyInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionesguardadasCreateInput = {
    publicaciones: publicacionesCreateNestedOneWithoutPublicacionesguardadasInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesguardadasInput
  }

  export type publicacionesguardadasUncheckedCreateInput = {
    idpublicacionesguardadas?: number
    idpublicacion: number
    idusuario: number
  }

  export type publicacionesguardadasUpdateInput = {
    publicaciones?: publicacionesUpdateOneRequiredWithoutPublicacionesguardadasNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesguardadasNestedInput
  }

  export type publicacionesguardadasUncheckedUpdateInput = {
    idpublicacionesguardadas?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionesguardadasCreateManyInput = {
    idpublicacionesguardadas?: number
    idpublicacion: number
    idusuario: number
  }

  export type publicacionesguardadasUpdateManyMutationInput = {

  }

  export type publicacionesguardadasUncheckedUpdateManyInput = {
    idpublicacionesguardadas?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionestableroCreateInput = {
    tablero: tableroCreateNestedOneWithoutPublicacionestableroInput
    publicaciones: publicacionesCreateNestedOneWithoutPublicacionestableroInput
  }

  export type publicacionestableroUncheckedCreateInput = {
    idpublicacionestablero?: number
    idtablero: number
    idpublicacion: number
  }

  export type publicacionestableroUpdateInput = {
    tablero?: tableroUpdateOneRequiredWithoutPublicacionestableroNestedInput
    publicaciones?: publicacionesUpdateOneRequiredWithoutPublicacionestableroNestedInput
  }

  export type publicacionestableroUncheckedUpdateInput = {
    idpublicacionestablero?: IntFieldUpdateOperationsInput | number
    idtablero?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionestableroCreateManyInput = {
    idpublicacionestablero?: number
    idtablero: number
    idpublicacion: number
  }

  export type publicacionestableroUpdateManyMutationInput = {

  }

  export type publicacionestableroUncheckedUpdateManyInput = {
    idpublicacionestablero?: IntFieldUpdateOperationsInput | number
    idtablero?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type tableroCreateInput = {
    nombre: string
    privacidad: number
    imagen?: Buffer | null
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutTableroInput
    usuario: usuarioCreateNestedOneWithoutTableroInput
  }

  export type tableroUncheckedCreateInput = {
    idtablero?: number
    nombre: string
    privacidad: number
    idusuario: number
    imagen?: Buffer | null
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutTableroInput
  }

  export type tableroUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    publicacionestablero?: publicacionestableroUpdateManyWithoutTableroNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutTableroNestedInput
  }

  export type tableroUncheckedUpdateInput = {
    idtablero?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutTableroNestedInput
  }

  export type tableroCreateManyInput = {
    idtablero?: number
    nombre: string
    privacidad: number
    idusuario: number
    imagen?: Buffer | null
  }

  export type tableroUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type tableroUncheckedUpdateManyInput = {
    idtablero?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type usuarioCreateInput = {
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosCreateNestedManyWithoutUsuarioInput
    publicaciones?: publicacionesCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutUsuarioInput
    tablero?: tableroCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    idusuario?: number
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUsuarioInput
    publicaciones?: publicacionesUncheckedCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutUsuarioInput
    tablero?: tableroUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUpdateManyWithoutUsuarioNestedInput
    publicaciones?: publicacionesUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUncheckedUpdateManyWithoutUsuarioNestedInput
    publicaciones?: publicacionesUncheckedUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    idusuario?: number
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
  }

  export type usuarioUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type PublicacionesListRelationFilter = {
    every?: publicacionesWhereInput
    some?: publicacionesWhereInput
    none?: publicacionesWhereInput
  }

  export type publicacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriasCountOrderByAggregateInput = {
    idcategorias?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
  }

  export type categoriasAvgOrderByAggregateInput = {
    idcategorias?: SortOrder
  }

  export type categoriasMaxOrderByAggregateInput = {
    idcategorias?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
  }

  export type categoriasMinOrderByAggregateInput = {
    idcategorias?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
  }

  export type categoriasSumOrderByAggregateInput = {
    idcategorias?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type PublicacionesRelationFilter = {
    is?: publicacionesWhereInput
    isNot?: publicacionesWhereInput
  }

  export type comentariosCountOrderByAggregateInput = {
    idcomentarios?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
  }

  export type comentariosAvgOrderByAggregateInput = {
    idcomentarios?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
  }

  export type comentariosMaxOrderByAggregateInput = {
    idcomentarios?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
  }

  export type comentariosMinOrderByAggregateInput = {
    idcomentarios?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
  }

  export type comentariosSumOrderByAggregateInput = {
    idcomentarios?: SortOrder
    idusuario?: SortOrder
    idpublicacion?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type imagenCountOrderByAggregateInput = {
    idimagen?: SortOrder
    imagen?: SortOrder
    idpublicacion?: SortOrder
  }

  export type imagenAvgOrderByAggregateInput = {
    idimagen?: SortOrder
    idpublicacion?: SortOrder
  }

  export type imagenMaxOrderByAggregateInput = {
    idimagen?: SortOrder
    imagen?: SortOrder
    idpublicacion?: SortOrder
  }

  export type imagenMinOrderByAggregateInput = {
    idimagen?: SortOrder
    imagen?: SortOrder
    idpublicacion?: SortOrder
  }

  export type imagenSumOrderByAggregateInput = {
    idimagen?: SortOrder
    idpublicacion?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type ComentariosListRelationFilter = {
    every?: comentariosWhereInput
    some?: comentariosWhereInput
    none?: comentariosWhereInput
  }

  export type ImagenListRelationFilter = {
    every?: imagenWhereInput
    some?: imagenWhereInput
    none?: imagenWhereInput
  }

  export type CategoriasRelationFilter = {
    is?: categoriasWhereInput
    isNot?: categoriasWhereInput
  }

  export type PublicacionesguardadasListRelationFilter = {
    every?: publicacionesguardadasWhereInput
    some?: publicacionesguardadasWhereInput
    none?: publicacionesguardadasWhereInput
  }

  export type PublicacionestableroListRelationFilter = {
    every?: publicacionestableroWhereInput
    some?: publicacionestableroWhereInput
    none?: publicacionestableroWhereInput
  }

  export type comentariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imagenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publicacionesguardadasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publicacionestableroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publicacionesCountOrderByAggregateInput = {
    idpublicaciones?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesAvgOrderByAggregateInput = {
    idpublicaciones?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesMaxOrderByAggregateInput = {
    idpublicaciones?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesMinOrderByAggregateInput = {
    idpublicaciones?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesSumOrderByAggregateInput = {
    idpublicaciones?: SortOrder
    idcategoria?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesguardadasCountOrderByAggregateInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesguardadasAvgOrderByAggregateInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesguardadasMaxOrderByAggregateInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesguardadasMinOrderByAggregateInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
  }

  export type publicacionesguardadasSumOrderByAggregateInput = {
    idpublicacionesguardadas?: SortOrder
    idpublicacion?: SortOrder
    idusuario?: SortOrder
  }

  export type TableroRelationFilter = {
    is?: tableroWhereInput
    isNot?: tableroWhereInput
  }

  export type publicacionestableroCountOrderByAggregateInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
  }

  export type publicacionestableroAvgOrderByAggregateInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
  }

  export type publicacionestableroMaxOrderByAggregateInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
  }

  export type publicacionestableroMinOrderByAggregateInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
  }

  export type publicacionestableroSumOrderByAggregateInput = {
    idpublicacionestablero?: SortOrder
    idtablero?: SortOrder
    idpublicacion?: SortOrder
  }

  export type tableroCountOrderByAggregateInput = {
    idtablero?: SortOrder
    nombre?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
    imagen?: SortOrder
  }

  export type tableroAvgOrderByAggregateInput = {
    idtablero?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
  }

  export type tableroMaxOrderByAggregateInput = {
    idtablero?: SortOrder
    nombre?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
    imagen?: SortOrder
  }

  export type tableroMinOrderByAggregateInput = {
    idtablero?: SortOrder
    nombre?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
    imagen?: SortOrder
  }

  export type tableroSumOrderByAggregateInput = {
    idtablero?: SortOrder
    privacidad?: SortOrder
    idusuario?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type TableroListRelationFilter = {
    every?: tableroWhereInput
    some?: tableroWhereInput
    none?: tableroWhereInput
  }

  export type tableroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    idusuario?: SortOrder
    username?: SortOrder
    email?: SortOrder
    userpassword?: SortOrder
    fotoperfil?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    idusuario?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    idusuario?: SortOrder
    username?: SortOrder
    email?: SortOrder
    userpassword?: SortOrder
    fotoperfil?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    idusuario?: SortOrder
    username?: SortOrder
    email?: SortOrder
    userpassword?: SortOrder
    fotoperfil?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    idusuario?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type publicacionesCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutCategoriasInput>, Enumerable<publicacionesUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutCategoriasInput>
    createMany?: publicacionesCreateManyCategoriasInputEnvelope
    connect?: Enumerable<publicacionesWhereUniqueInput>
  }

  export type publicacionesUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutCategoriasInput>, Enumerable<publicacionesUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutCategoriasInput>
    createMany?: publicacionesCreateManyCategoriasInputEnvelope
    connect?: Enumerable<publicacionesWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type publicacionesUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutCategoriasInput>, Enumerable<publicacionesUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutCategoriasInput>
    upsert?: Enumerable<publicacionesUpsertWithWhereUniqueWithoutCategoriasInput>
    createMany?: publicacionesCreateManyCategoriasInputEnvelope
    set?: Enumerable<publicacionesWhereUniqueInput>
    disconnect?: Enumerable<publicacionesWhereUniqueInput>
    delete?: Enumerable<publicacionesWhereUniqueInput>
    connect?: Enumerable<publicacionesWhereUniqueInput>
    update?: Enumerable<publicacionesUpdateWithWhereUniqueWithoutCategoriasInput>
    updateMany?: Enumerable<publicacionesUpdateManyWithWhereWithoutCategoriasInput>
    deleteMany?: Enumerable<publicacionesScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type publicacionesUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutCategoriasInput>, Enumerable<publicacionesUncheckedCreateWithoutCategoriasInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutCategoriasInput>
    upsert?: Enumerable<publicacionesUpsertWithWhereUniqueWithoutCategoriasInput>
    createMany?: publicacionesCreateManyCategoriasInputEnvelope
    set?: Enumerable<publicacionesWhereUniqueInput>
    disconnect?: Enumerable<publicacionesWhereUniqueInput>
    delete?: Enumerable<publicacionesWhereUniqueInput>
    connect?: Enumerable<publicacionesWhereUniqueInput>
    update?: Enumerable<publicacionesUpdateWithWhereUniqueWithoutCategoriasInput>
    updateMany?: Enumerable<publicacionesUpdateManyWithWhereWithoutCategoriasInput>
    deleteMany?: Enumerable<publicacionesScalarWhereInput>
  }

  export type usuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutComentariosInput
    connect?: usuarioWhereUniqueInput
  }

  export type publicacionesCreateNestedOneWithoutComentariosInput = {
    create?: XOR<publicacionesCreateWithoutComentariosInput, publicacionesUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutComentariosInput
    connect?: publicacionesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usuarioUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutComentariosInput
    upsert?: usuarioUpsertWithoutComentariosInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutComentariosInput, usuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type publicacionesUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<publicacionesCreateWithoutComentariosInput, publicacionesUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutComentariosInput
    upsert?: publicacionesUpsertWithoutComentariosInput
    connect?: publicacionesWhereUniqueInput
    update?: XOR<publicacionesUpdateWithoutComentariosInput, publicacionesUncheckedUpdateWithoutComentariosInput>
  }

  export type publicacionesCreateNestedOneWithoutImagenInput = {
    create?: XOR<publicacionesCreateWithoutImagenInput, publicacionesUncheckedCreateWithoutImagenInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutImagenInput
    connect?: publicacionesWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type publicacionesUpdateOneRequiredWithoutImagenNestedInput = {
    create?: XOR<publicacionesCreateWithoutImagenInput, publicacionesUncheckedCreateWithoutImagenInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutImagenInput
    upsert?: publicacionesUpsertWithoutImagenInput
    connect?: publicacionesWhereUniqueInput
    update?: XOR<publicacionesUpdateWithoutImagenInput, publicacionesUncheckedUpdateWithoutImagenInput>
  }

  export type comentariosCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutPublicacionesInput>, Enumerable<comentariosUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutPublicacionesInput>
    createMany?: comentariosCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<comentariosWhereUniqueInput>
  }

  export type imagenCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<imagenCreateWithoutPublicacionesInput>, Enumerable<imagenUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<imagenCreateOrConnectWithoutPublicacionesInput>
    createMany?: imagenCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<imagenWhereUniqueInput>
  }

  export type categoriasCreateNestedOneWithoutPublicacionesInput = {
    create?: XOR<categoriasCreateWithoutPublicacionesInput, categoriasUncheckedCreateWithoutPublicacionesInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutPublicacionesInput
    connect?: categoriasWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutPublicacionesInput = {
    create?: XOR<usuarioCreateWithoutPublicacionesInput, usuarioUncheckedCreateWithoutPublicacionesInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPublicacionesInput
    connect?: usuarioWhereUniqueInput
  }

  export type publicacionesguardadasCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutPublicacionesInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutPublicacionesInput>
    createMany?: publicacionesguardadasCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
  }

  export type publicacionestableroCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutPublicacionesInput>, Enumerable<publicacionestableroUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutPublicacionesInput>
    createMany?: publicacionestableroCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
  }

  export type comentariosUncheckedCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutPublicacionesInput>, Enumerable<comentariosUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutPublicacionesInput>
    createMany?: comentariosCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<comentariosWhereUniqueInput>
  }

  export type imagenUncheckedCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<imagenCreateWithoutPublicacionesInput>, Enumerable<imagenUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<imagenCreateOrConnectWithoutPublicacionesInput>
    createMany?: imagenCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<imagenWhereUniqueInput>
  }

  export type publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutPublicacionesInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutPublicacionesInput>
    createMany?: publicacionesguardadasCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
  }

  export type publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutPublicacionesInput>, Enumerable<publicacionestableroUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutPublicacionesInput>
    createMany?: publicacionestableroCreateManyPublicacionesInputEnvelope
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
  }

  export type comentariosUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutPublicacionesInput>, Enumerable<comentariosUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<comentariosUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: comentariosCreateManyPublicacionesInputEnvelope
    set?: Enumerable<comentariosWhereUniqueInput>
    disconnect?: Enumerable<comentariosWhereUniqueInput>
    delete?: Enumerable<comentariosWhereUniqueInput>
    connect?: Enumerable<comentariosWhereUniqueInput>
    update?: Enumerable<comentariosUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<comentariosUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<comentariosScalarWhereInput>
  }

  export type imagenUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<imagenCreateWithoutPublicacionesInput>, Enumerable<imagenUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<imagenCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<imagenUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: imagenCreateManyPublicacionesInputEnvelope
    set?: Enumerable<imagenWhereUniqueInput>
    disconnect?: Enumerable<imagenWhereUniqueInput>
    delete?: Enumerable<imagenWhereUniqueInput>
    connect?: Enumerable<imagenWhereUniqueInput>
    update?: Enumerable<imagenUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<imagenUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<imagenScalarWhereInput>
  }

  export type categoriasUpdateOneRequiredWithoutPublicacionesNestedInput = {
    create?: XOR<categoriasCreateWithoutPublicacionesInput, categoriasUncheckedCreateWithoutPublicacionesInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutPublicacionesInput
    upsert?: categoriasUpsertWithoutPublicacionesInput
    connect?: categoriasWhereUniqueInput
    update?: XOR<categoriasUpdateWithoutPublicacionesInput, categoriasUncheckedUpdateWithoutPublicacionesInput>
  }

  export type usuarioUpdateOneRequiredWithoutPublicacionesNestedInput = {
    create?: XOR<usuarioCreateWithoutPublicacionesInput, usuarioUncheckedCreateWithoutPublicacionesInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPublicacionesInput
    upsert?: usuarioUpsertWithoutPublicacionesInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutPublicacionesInput, usuarioUncheckedUpdateWithoutPublicacionesInput>
  }

  export type publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutPublicacionesInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<publicacionesguardadasUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: publicacionesguardadasCreateManyPublicacionesInputEnvelope
    set?: Enumerable<publicacionesguardadasWhereUniqueInput>
    disconnect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    delete?: Enumerable<publicacionesguardadasWhereUniqueInput>
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    update?: Enumerable<publicacionesguardadasUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<publicacionesguardadasUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<publicacionesguardadasScalarWhereInput>
  }

  export type publicacionestableroUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutPublicacionesInput>, Enumerable<publicacionestableroUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<publicacionestableroUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: publicacionestableroCreateManyPublicacionesInputEnvelope
    set?: Enumerable<publicacionestableroWhereUniqueInput>
    disconnect?: Enumerable<publicacionestableroWhereUniqueInput>
    delete?: Enumerable<publicacionestableroWhereUniqueInput>
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
    update?: Enumerable<publicacionestableroUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<publicacionestableroUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<publicacionestableroScalarWhereInput>
  }

  export type comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutPublicacionesInput>, Enumerable<comentariosUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<comentariosUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: comentariosCreateManyPublicacionesInputEnvelope
    set?: Enumerable<comentariosWhereUniqueInput>
    disconnect?: Enumerable<comentariosWhereUniqueInput>
    delete?: Enumerable<comentariosWhereUniqueInput>
    connect?: Enumerable<comentariosWhereUniqueInput>
    update?: Enumerable<comentariosUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<comentariosUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<comentariosScalarWhereInput>
  }

  export type imagenUncheckedUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<imagenCreateWithoutPublicacionesInput>, Enumerable<imagenUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<imagenCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<imagenUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: imagenCreateManyPublicacionesInputEnvelope
    set?: Enumerable<imagenWhereUniqueInput>
    disconnect?: Enumerable<imagenWhereUniqueInput>
    delete?: Enumerable<imagenWhereUniqueInput>
    connect?: Enumerable<imagenWhereUniqueInput>
    update?: Enumerable<imagenUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<imagenUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<imagenScalarWhereInput>
  }

  export type publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutPublicacionesInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<publicacionesguardadasUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: publicacionesguardadasCreateManyPublicacionesInputEnvelope
    set?: Enumerable<publicacionesguardadasWhereUniqueInput>
    disconnect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    delete?: Enumerable<publicacionesguardadasWhereUniqueInput>
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    update?: Enumerable<publicacionesguardadasUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<publicacionesguardadasUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<publicacionesguardadasScalarWhereInput>
  }

  export type publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutPublicacionesInput>, Enumerable<publicacionestableroUncheckedCreateWithoutPublicacionesInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutPublicacionesInput>
    upsert?: Enumerable<publicacionestableroUpsertWithWhereUniqueWithoutPublicacionesInput>
    createMany?: publicacionestableroCreateManyPublicacionesInputEnvelope
    set?: Enumerable<publicacionestableroWhereUniqueInput>
    disconnect?: Enumerable<publicacionestableroWhereUniqueInput>
    delete?: Enumerable<publicacionestableroWhereUniqueInput>
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
    update?: Enumerable<publicacionestableroUpdateWithWhereUniqueWithoutPublicacionesInput>
    updateMany?: Enumerable<publicacionestableroUpdateManyWithWhereWithoutPublicacionesInput>
    deleteMany?: Enumerable<publicacionestableroScalarWhereInput>
  }

  export type publicacionesCreateNestedOneWithoutPublicacionesguardadasInput = {
    create?: XOR<publicacionesCreateWithoutPublicacionesguardadasInput, publicacionesUncheckedCreateWithoutPublicacionesguardadasInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutPublicacionesguardadasInput
    connect?: publicacionesWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutPublicacionesguardadasInput = {
    create?: XOR<usuarioCreateWithoutPublicacionesguardadasInput, usuarioUncheckedCreateWithoutPublicacionesguardadasInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPublicacionesguardadasInput
    connect?: usuarioWhereUniqueInput
  }

  export type publicacionesUpdateOneRequiredWithoutPublicacionesguardadasNestedInput = {
    create?: XOR<publicacionesCreateWithoutPublicacionesguardadasInput, publicacionesUncheckedCreateWithoutPublicacionesguardadasInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutPublicacionesguardadasInput
    upsert?: publicacionesUpsertWithoutPublicacionesguardadasInput
    connect?: publicacionesWhereUniqueInput
    update?: XOR<publicacionesUpdateWithoutPublicacionesguardadasInput, publicacionesUncheckedUpdateWithoutPublicacionesguardadasInput>
  }

  export type usuarioUpdateOneRequiredWithoutPublicacionesguardadasNestedInput = {
    create?: XOR<usuarioCreateWithoutPublicacionesguardadasInput, usuarioUncheckedCreateWithoutPublicacionesguardadasInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPublicacionesguardadasInput
    upsert?: usuarioUpsertWithoutPublicacionesguardadasInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutPublicacionesguardadasInput, usuarioUncheckedUpdateWithoutPublicacionesguardadasInput>
  }

  export type tableroCreateNestedOneWithoutPublicacionestableroInput = {
    create?: XOR<tableroCreateWithoutPublicacionestableroInput, tableroUncheckedCreateWithoutPublicacionestableroInput>
    connectOrCreate?: tableroCreateOrConnectWithoutPublicacionestableroInput
    connect?: tableroWhereUniqueInput
  }

  export type publicacionesCreateNestedOneWithoutPublicacionestableroInput = {
    create?: XOR<publicacionesCreateWithoutPublicacionestableroInput, publicacionesUncheckedCreateWithoutPublicacionestableroInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutPublicacionestableroInput
    connect?: publicacionesWhereUniqueInput
  }

  export type tableroUpdateOneRequiredWithoutPublicacionestableroNestedInput = {
    create?: XOR<tableroCreateWithoutPublicacionestableroInput, tableroUncheckedCreateWithoutPublicacionestableroInput>
    connectOrCreate?: tableroCreateOrConnectWithoutPublicacionestableroInput
    upsert?: tableroUpsertWithoutPublicacionestableroInput
    connect?: tableroWhereUniqueInput
    update?: XOR<tableroUpdateWithoutPublicacionestableroInput, tableroUncheckedUpdateWithoutPublicacionestableroInput>
  }

  export type publicacionesUpdateOneRequiredWithoutPublicacionestableroNestedInput = {
    create?: XOR<publicacionesCreateWithoutPublicacionestableroInput, publicacionesUncheckedCreateWithoutPublicacionestableroInput>
    connectOrCreate?: publicacionesCreateOrConnectWithoutPublicacionestableroInput
    upsert?: publicacionesUpsertWithoutPublicacionestableroInput
    connect?: publicacionesWhereUniqueInput
    update?: XOR<publicacionesUpdateWithoutPublicacionestableroInput, publicacionesUncheckedUpdateWithoutPublicacionestableroInput>
  }

  export type publicacionestableroCreateNestedManyWithoutTableroInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutTableroInput>, Enumerable<publicacionestableroUncheckedCreateWithoutTableroInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutTableroInput>
    createMany?: publicacionestableroCreateManyTableroInputEnvelope
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
  }

  export type usuarioCreateNestedOneWithoutTableroInput = {
    create?: XOR<usuarioCreateWithoutTableroInput, usuarioUncheckedCreateWithoutTableroInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutTableroInput
    connect?: usuarioWhereUniqueInput
  }

  export type publicacionestableroUncheckedCreateNestedManyWithoutTableroInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutTableroInput>, Enumerable<publicacionestableroUncheckedCreateWithoutTableroInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutTableroInput>
    createMany?: publicacionestableroCreateManyTableroInputEnvelope
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
  }

  export type publicacionestableroUpdateManyWithoutTableroNestedInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutTableroInput>, Enumerable<publicacionestableroUncheckedCreateWithoutTableroInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutTableroInput>
    upsert?: Enumerable<publicacionestableroUpsertWithWhereUniqueWithoutTableroInput>
    createMany?: publicacionestableroCreateManyTableroInputEnvelope
    set?: Enumerable<publicacionestableroWhereUniqueInput>
    disconnect?: Enumerable<publicacionestableroWhereUniqueInput>
    delete?: Enumerable<publicacionestableroWhereUniqueInput>
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
    update?: Enumerable<publicacionestableroUpdateWithWhereUniqueWithoutTableroInput>
    updateMany?: Enumerable<publicacionestableroUpdateManyWithWhereWithoutTableroInput>
    deleteMany?: Enumerable<publicacionestableroScalarWhereInput>
  }

  export type usuarioUpdateOneRequiredWithoutTableroNestedInput = {
    create?: XOR<usuarioCreateWithoutTableroInput, usuarioUncheckedCreateWithoutTableroInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutTableroInput
    upsert?: usuarioUpsertWithoutTableroInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutTableroInput, usuarioUncheckedUpdateWithoutTableroInput>
  }

  export type publicacionestableroUncheckedUpdateManyWithoutTableroNestedInput = {
    create?: XOR<Enumerable<publicacionestableroCreateWithoutTableroInput>, Enumerable<publicacionestableroUncheckedCreateWithoutTableroInput>>
    connectOrCreate?: Enumerable<publicacionestableroCreateOrConnectWithoutTableroInput>
    upsert?: Enumerable<publicacionestableroUpsertWithWhereUniqueWithoutTableroInput>
    createMany?: publicacionestableroCreateManyTableroInputEnvelope
    set?: Enumerable<publicacionestableroWhereUniqueInput>
    disconnect?: Enumerable<publicacionestableroWhereUniqueInput>
    delete?: Enumerable<publicacionestableroWhereUniqueInput>
    connect?: Enumerable<publicacionestableroWhereUniqueInput>
    update?: Enumerable<publicacionestableroUpdateWithWhereUniqueWithoutTableroInput>
    updateMany?: Enumerable<publicacionestableroUpdateManyWithWhereWithoutTableroInput>
    deleteMany?: Enumerable<publicacionestableroScalarWhereInput>
  }

  export type comentariosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutUsuarioInput>, Enumerable<comentariosUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutUsuarioInput>
    createMany?: comentariosCreateManyUsuarioInputEnvelope
    connect?: Enumerable<comentariosWhereUniqueInput>
  }

  export type publicacionesCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutUsuarioInput>, Enumerable<publicacionesUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutUsuarioInput>
    createMany?: publicacionesCreateManyUsuarioInputEnvelope
    connect?: Enumerable<publicacionesWhereUniqueInput>
  }

  export type publicacionesguardadasCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutUsuarioInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutUsuarioInput>
    createMany?: publicacionesguardadasCreateManyUsuarioInputEnvelope
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
  }

  export type tableroCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<tableroCreateWithoutUsuarioInput>, Enumerable<tableroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<tableroCreateOrConnectWithoutUsuarioInput>
    createMany?: tableroCreateManyUsuarioInputEnvelope
    connect?: Enumerable<tableroWhereUniqueInput>
  }

  export type comentariosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutUsuarioInput>, Enumerable<comentariosUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutUsuarioInput>
    createMany?: comentariosCreateManyUsuarioInputEnvelope
    connect?: Enumerable<comentariosWhereUniqueInput>
  }

  export type publicacionesUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutUsuarioInput>, Enumerable<publicacionesUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutUsuarioInput>
    createMany?: publicacionesCreateManyUsuarioInputEnvelope
    connect?: Enumerable<publicacionesWhereUniqueInput>
  }

  export type publicacionesguardadasUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutUsuarioInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutUsuarioInput>
    createMany?: publicacionesguardadasCreateManyUsuarioInputEnvelope
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
  }

  export type tableroUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<tableroCreateWithoutUsuarioInput>, Enumerable<tableroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<tableroCreateOrConnectWithoutUsuarioInput>
    createMany?: tableroCreateManyUsuarioInputEnvelope
    connect?: Enumerable<tableroWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type comentariosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutUsuarioInput>, Enumerable<comentariosUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<comentariosUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: comentariosCreateManyUsuarioInputEnvelope
    set?: Enumerable<comentariosWhereUniqueInput>
    disconnect?: Enumerable<comentariosWhereUniqueInput>
    delete?: Enumerable<comentariosWhereUniqueInput>
    connect?: Enumerable<comentariosWhereUniqueInput>
    update?: Enumerable<comentariosUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<comentariosUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<comentariosScalarWhereInput>
  }

  export type publicacionesUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutUsuarioInput>, Enumerable<publicacionesUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<publicacionesUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: publicacionesCreateManyUsuarioInputEnvelope
    set?: Enumerable<publicacionesWhereUniqueInput>
    disconnect?: Enumerable<publicacionesWhereUniqueInput>
    delete?: Enumerable<publicacionesWhereUniqueInput>
    connect?: Enumerable<publicacionesWhereUniqueInput>
    update?: Enumerable<publicacionesUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<publicacionesUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<publicacionesScalarWhereInput>
  }

  export type publicacionesguardadasUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutUsuarioInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<publicacionesguardadasUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: publicacionesguardadasCreateManyUsuarioInputEnvelope
    set?: Enumerable<publicacionesguardadasWhereUniqueInput>
    disconnect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    delete?: Enumerable<publicacionesguardadasWhereUniqueInput>
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    update?: Enumerable<publicacionesguardadasUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<publicacionesguardadasUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<publicacionesguardadasScalarWhereInput>
  }

  export type tableroUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<tableroCreateWithoutUsuarioInput>, Enumerable<tableroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<tableroCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<tableroUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: tableroCreateManyUsuarioInputEnvelope
    set?: Enumerable<tableroWhereUniqueInput>
    disconnect?: Enumerable<tableroWhereUniqueInput>
    delete?: Enumerable<tableroWhereUniqueInput>
    connect?: Enumerable<tableroWhereUniqueInput>
    update?: Enumerable<tableroUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<tableroUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<tableroScalarWhereInput>
  }

  export type comentariosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<comentariosCreateWithoutUsuarioInput>, Enumerable<comentariosUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<comentariosCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<comentariosUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: comentariosCreateManyUsuarioInputEnvelope
    set?: Enumerable<comentariosWhereUniqueInput>
    disconnect?: Enumerable<comentariosWhereUniqueInput>
    delete?: Enumerable<comentariosWhereUniqueInput>
    connect?: Enumerable<comentariosWhereUniqueInput>
    update?: Enumerable<comentariosUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<comentariosUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<comentariosScalarWhereInput>
  }

  export type publicacionesUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<publicacionesCreateWithoutUsuarioInput>, Enumerable<publicacionesUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<publicacionesUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: publicacionesCreateManyUsuarioInputEnvelope
    set?: Enumerable<publicacionesWhereUniqueInput>
    disconnect?: Enumerable<publicacionesWhereUniqueInput>
    delete?: Enumerable<publicacionesWhereUniqueInput>
    connect?: Enumerable<publicacionesWhereUniqueInput>
    update?: Enumerable<publicacionesUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<publicacionesUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<publicacionesScalarWhereInput>
  }

  export type publicacionesguardadasUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<publicacionesguardadasCreateWithoutUsuarioInput>, Enumerable<publicacionesguardadasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<publicacionesguardadasCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<publicacionesguardadasUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: publicacionesguardadasCreateManyUsuarioInputEnvelope
    set?: Enumerable<publicacionesguardadasWhereUniqueInput>
    disconnect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    delete?: Enumerable<publicacionesguardadasWhereUniqueInput>
    connect?: Enumerable<publicacionesguardadasWhereUniqueInput>
    update?: Enumerable<publicacionesguardadasUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<publicacionesguardadasUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<publicacionesguardadasScalarWhereInput>
  }

  export type tableroUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<tableroCreateWithoutUsuarioInput>, Enumerable<tableroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<tableroCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<tableroUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: tableroCreateManyUsuarioInputEnvelope
    set?: Enumerable<tableroWhereUniqueInput>
    disconnect?: Enumerable<tableroWhereUniqueInput>
    delete?: Enumerable<tableroWhereUniqueInput>
    connect?: Enumerable<tableroWhereUniqueInput>
    update?: Enumerable<tableroUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<tableroUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<tableroScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type publicacionesCreateWithoutCategoriasInput = {
    titulo: string
    descripcion: string
    comentarios?: comentariosCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenCreateNestedManyWithoutPublicacionesInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateWithoutCategoriasInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idusuario: number
    comentarios?: comentariosUncheckedCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesCreateOrConnectWithoutCategoriasInput = {
    where: publicacionesWhereUniqueInput
    create: XOR<publicacionesCreateWithoutCategoriasInput, publicacionesUncheckedCreateWithoutCategoriasInput>
  }

  export type publicacionesCreateManyCategoriasInputEnvelope = {
    data: Enumerable<publicacionesCreateManyCategoriasInput>
    skipDuplicates?: boolean
  }

  export type publicacionesUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: publicacionesWhereUniqueInput
    update: XOR<publicacionesUpdateWithoutCategoriasInput, publicacionesUncheckedUpdateWithoutCategoriasInput>
    create: XOR<publicacionesCreateWithoutCategoriasInput, publicacionesUncheckedCreateWithoutCategoriasInput>
  }

  export type publicacionesUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: publicacionesWhereUniqueInput
    data: XOR<publicacionesUpdateWithoutCategoriasInput, publicacionesUncheckedUpdateWithoutCategoriasInput>
  }

  export type publicacionesUpdateManyWithWhereWithoutCategoriasInput = {
    where: publicacionesScalarWhereInput
    data: XOR<publicacionesUpdateManyMutationInput, publicacionesUncheckedUpdateManyWithoutPublicacionesInput>
  }

  export type publicacionesScalarWhereInput = {
    AND?: Enumerable<publicacionesScalarWhereInput>
    OR?: Enumerable<publicacionesScalarWhereInput>
    NOT?: Enumerable<publicacionesScalarWhereInput>
    idpublicaciones?: IntFilter | number
    titulo?: StringFilter | string
    descripcion?: StringFilter | string
    idcategoria?: IntFilter | number
    idusuario?: IntFilter | number
  }

  export type usuarioCreateWithoutComentariosInput = {
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    publicaciones?: publicacionesCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutUsuarioInput
    tablero?: tableroCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutComentariosInput = {
    idusuario?: number
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    publicaciones?: publicacionesUncheckedCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutUsuarioInput
    tablero?: tableroUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutComentariosInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
  }

  export type publicacionesCreateWithoutComentariosInput = {
    titulo: string
    descripcion: string
    imagen?: imagenCreateNestedManyWithoutPublicacionesInput
    categorias: categoriasCreateNestedOneWithoutPublicacionesInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateWithoutComentariosInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
    imagen?: imagenUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesCreateOrConnectWithoutComentariosInput = {
    where: publicacionesWhereUniqueInput
    create: XOR<publicacionesCreateWithoutComentariosInput, publicacionesUncheckedCreateWithoutComentariosInput>
  }

  export type usuarioUpsertWithoutComentariosInput = {
    update: XOR<usuarioUpdateWithoutComentariosInput, usuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
  }

  export type usuarioUpdateWithoutComentariosInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    publicaciones?: publicacionesUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutComentariosInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    publicaciones?: publicacionesUncheckedUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type publicacionesUpsertWithoutComentariosInput = {
    update: XOR<publicacionesUpdateWithoutComentariosInput, publicacionesUncheckedUpdateWithoutComentariosInput>
    create: XOR<publicacionesCreateWithoutComentariosInput, publicacionesUncheckedCreateWithoutComentariosInput>
  }

  export type publicacionesUpdateWithoutComentariosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: imagenUpdateManyWithoutPublicacionesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutPublicacionesNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateWithoutComentariosInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    imagen?: imagenUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesCreateWithoutImagenInput = {
    titulo: string
    descripcion: string
    comentarios?: comentariosCreateNestedManyWithoutPublicacionesInput
    categorias: categoriasCreateNestedOneWithoutPublicacionesInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateWithoutImagenInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
    comentarios?: comentariosUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesCreateOrConnectWithoutImagenInput = {
    where: publicacionesWhereUniqueInput
    create: XOR<publicacionesCreateWithoutImagenInput, publicacionesUncheckedCreateWithoutImagenInput>
  }

  export type publicacionesUpsertWithoutImagenInput = {
    update: XOR<publicacionesUpdateWithoutImagenInput, publicacionesUncheckedUpdateWithoutImagenInput>
    create: XOR<publicacionesCreateWithoutImagenInput, publicacionesUncheckedCreateWithoutImagenInput>
  }

  export type publicacionesUpdateWithoutImagenInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    comentarios?: comentariosUpdateManyWithoutPublicacionesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutPublicacionesNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateWithoutImagenInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    comentarios?: comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type comentariosCreateWithoutPublicacionesInput = {
    descripcion: string
    fecha: Date | string
    usuario: usuarioCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateWithoutPublicacionesInput = {
    idcomentarios?: number
    descripcion: string
    fecha: Date | string
    idusuario: number
  }

  export type comentariosCreateOrConnectWithoutPublicacionesInput = {
    where: comentariosWhereUniqueInput
    create: XOR<comentariosCreateWithoutPublicacionesInput, comentariosUncheckedCreateWithoutPublicacionesInput>
  }

  export type comentariosCreateManyPublicacionesInputEnvelope = {
    data: Enumerable<comentariosCreateManyPublicacionesInput>
    skipDuplicates?: boolean
  }

  export type imagenCreateWithoutPublicacionesInput = {
    imagen: Buffer
  }

  export type imagenUncheckedCreateWithoutPublicacionesInput = {
    idimagen?: number
    imagen: Buffer
  }

  export type imagenCreateOrConnectWithoutPublicacionesInput = {
    where: imagenWhereUniqueInput
    create: XOR<imagenCreateWithoutPublicacionesInput, imagenUncheckedCreateWithoutPublicacionesInput>
  }

  export type imagenCreateManyPublicacionesInputEnvelope = {
    data: Enumerable<imagenCreateManyPublicacionesInput>
    skipDuplicates?: boolean
  }

  export type categoriasCreateWithoutPublicacionesInput = {
    nombre: string
    imagen?: Buffer | null
  }

  export type categoriasUncheckedCreateWithoutPublicacionesInput = {
    idcategorias?: number
    nombre: string
    imagen?: Buffer | null
  }

  export type categoriasCreateOrConnectWithoutPublicacionesInput = {
    where: categoriasWhereUniqueInput
    create: XOR<categoriasCreateWithoutPublicacionesInput, categoriasUncheckedCreateWithoutPublicacionesInput>
  }

  export type usuarioCreateWithoutPublicacionesInput = {
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutUsuarioInput
    tablero?: tableroCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPublicacionesInput = {
    idusuario?: number
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutUsuarioInput
    tablero?: tableroUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPublicacionesInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPublicacionesInput, usuarioUncheckedCreateWithoutPublicacionesInput>
  }

  export type publicacionesguardadasCreateWithoutPublicacionesInput = {
    usuario: usuarioCreateNestedOneWithoutPublicacionesguardadasInput
  }

  export type publicacionesguardadasUncheckedCreateWithoutPublicacionesInput = {
    idpublicacionesguardadas?: number
    idusuario: number
  }

  export type publicacionesguardadasCreateOrConnectWithoutPublicacionesInput = {
    where: publicacionesguardadasWhereUniqueInput
    create: XOR<publicacionesguardadasCreateWithoutPublicacionesInput, publicacionesguardadasUncheckedCreateWithoutPublicacionesInput>
  }

  export type publicacionesguardadasCreateManyPublicacionesInputEnvelope = {
    data: Enumerable<publicacionesguardadasCreateManyPublicacionesInput>
    skipDuplicates?: boolean
  }

  export type publicacionestableroCreateWithoutPublicacionesInput = {
    tablero: tableroCreateNestedOneWithoutPublicacionestableroInput
  }

  export type publicacionestableroUncheckedCreateWithoutPublicacionesInput = {
    idpublicacionestablero?: number
    idtablero: number
  }

  export type publicacionestableroCreateOrConnectWithoutPublicacionesInput = {
    where: publicacionestableroWhereUniqueInput
    create: XOR<publicacionestableroCreateWithoutPublicacionesInput, publicacionestableroUncheckedCreateWithoutPublicacionesInput>
  }

  export type publicacionestableroCreateManyPublicacionesInputEnvelope = {
    data: Enumerable<publicacionestableroCreateManyPublicacionesInput>
    skipDuplicates?: boolean
  }

  export type comentariosUpsertWithWhereUniqueWithoutPublicacionesInput = {
    where: comentariosWhereUniqueInput
    update: XOR<comentariosUpdateWithoutPublicacionesInput, comentariosUncheckedUpdateWithoutPublicacionesInput>
    create: XOR<comentariosCreateWithoutPublicacionesInput, comentariosUncheckedCreateWithoutPublicacionesInput>
  }

  export type comentariosUpdateWithWhereUniqueWithoutPublicacionesInput = {
    where: comentariosWhereUniqueInput
    data: XOR<comentariosUpdateWithoutPublicacionesInput, comentariosUncheckedUpdateWithoutPublicacionesInput>
  }

  export type comentariosUpdateManyWithWhereWithoutPublicacionesInput = {
    where: comentariosScalarWhereInput
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyWithoutComentariosInput>
  }

  export type comentariosScalarWhereInput = {
    AND?: Enumerable<comentariosScalarWhereInput>
    OR?: Enumerable<comentariosScalarWhereInput>
    NOT?: Enumerable<comentariosScalarWhereInput>
    idcomentarios?: IntFilter | number
    descripcion?: StringFilter | string
    fecha?: DateTimeFilter | Date | string
    idusuario?: IntFilter | number
    idpublicacion?: IntFilter | number
  }

  export type imagenUpsertWithWhereUniqueWithoutPublicacionesInput = {
    where: imagenWhereUniqueInput
    update: XOR<imagenUpdateWithoutPublicacionesInput, imagenUncheckedUpdateWithoutPublicacionesInput>
    create: XOR<imagenCreateWithoutPublicacionesInput, imagenUncheckedCreateWithoutPublicacionesInput>
  }

  export type imagenUpdateWithWhereUniqueWithoutPublicacionesInput = {
    where: imagenWhereUniqueInput
    data: XOR<imagenUpdateWithoutPublicacionesInput, imagenUncheckedUpdateWithoutPublicacionesInput>
  }

  export type imagenUpdateManyWithWhereWithoutPublicacionesInput = {
    where: imagenScalarWhereInput
    data: XOR<imagenUpdateManyMutationInput, imagenUncheckedUpdateManyWithoutImagenInput>
  }

  export type imagenScalarWhereInput = {
    AND?: Enumerable<imagenScalarWhereInput>
    OR?: Enumerable<imagenScalarWhereInput>
    NOT?: Enumerable<imagenScalarWhereInput>
    idimagen?: IntFilter | number
    imagen?: BytesFilter | Buffer
    idpublicacion?: IntFilter | number
  }

  export type categoriasUpsertWithoutPublicacionesInput = {
    update: XOR<categoriasUpdateWithoutPublicacionesInput, categoriasUncheckedUpdateWithoutPublicacionesInput>
    create: XOR<categoriasCreateWithoutPublicacionesInput, categoriasUncheckedCreateWithoutPublicacionesInput>
  }

  export type categoriasUpdateWithoutPublicacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type categoriasUncheckedUpdateWithoutPublicacionesInput = {
    idcategorias?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type usuarioUpsertWithoutPublicacionesInput = {
    update: XOR<usuarioUpdateWithoutPublicacionesInput, usuarioUncheckedUpdateWithoutPublicacionesInput>
    create: XOR<usuarioCreateWithoutPublicacionesInput, usuarioUncheckedCreateWithoutPublicacionesInput>
  }

  export type usuarioUpdateWithoutPublicacionesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPublicacionesInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUncheckedUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type publicacionesguardadasUpsertWithWhereUniqueWithoutPublicacionesInput = {
    where: publicacionesguardadasWhereUniqueInput
    update: XOR<publicacionesguardadasUpdateWithoutPublicacionesInput, publicacionesguardadasUncheckedUpdateWithoutPublicacionesInput>
    create: XOR<publicacionesguardadasCreateWithoutPublicacionesInput, publicacionesguardadasUncheckedCreateWithoutPublicacionesInput>
  }

  export type publicacionesguardadasUpdateWithWhereUniqueWithoutPublicacionesInput = {
    where: publicacionesguardadasWhereUniqueInput
    data: XOR<publicacionesguardadasUpdateWithoutPublicacionesInput, publicacionesguardadasUncheckedUpdateWithoutPublicacionesInput>
  }

  export type publicacionesguardadasUpdateManyWithWhereWithoutPublicacionesInput = {
    where: publicacionesguardadasScalarWhereInput
    data: XOR<publicacionesguardadasUpdateManyMutationInput, publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesguardadasInput>
  }

  export type publicacionesguardadasScalarWhereInput = {
    AND?: Enumerable<publicacionesguardadasScalarWhereInput>
    OR?: Enumerable<publicacionesguardadasScalarWhereInput>
    NOT?: Enumerable<publicacionesguardadasScalarWhereInput>
    idpublicacionesguardadas?: IntFilter | number
    idpublicacion?: IntFilter | number
    idusuario?: IntFilter | number
  }

  export type publicacionestableroUpsertWithWhereUniqueWithoutPublicacionesInput = {
    where: publicacionestableroWhereUniqueInput
    update: XOR<publicacionestableroUpdateWithoutPublicacionesInput, publicacionestableroUncheckedUpdateWithoutPublicacionesInput>
    create: XOR<publicacionestableroCreateWithoutPublicacionesInput, publicacionestableroUncheckedCreateWithoutPublicacionesInput>
  }

  export type publicacionestableroUpdateWithWhereUniqueWithoutPublicacionesInput = {
    where: publicacionestableroWhereUniqueInput
    data: XOR<publicacionestableroUpdateWithoutPublicacionesInput, publicacionestableroUncheckedUpdateWithoutPublicacionesInput>
  }

  export type publicacionestableroUpdateManyWithWhereWithoutPublicacionesInput = {
    where: publicacionestableroScalarWhereInput
    data: XOR<publicacionestableroUpdateManyMutationInput, publicacionestableroUncheckedUpdateManyWithoutPublicacionestableroInput>
  }

  export type publicacionestableroScalarWhereInput = {
    AND?: Enumerable<publicacionestableroScalarWhereInput>
    OR?: Enumerable<publicacionestableroScalarWhereInput>
    NOT?: Enumerable<publicacionestableroScalarWhereInput>
    idpublicacionestablero?: IntFilter | number
    idtablero?: IntFilter | number
    idpublicacion?: IntFilter | number
  }

  export type publicacionesCreateWithoutPublicacionesguardadasInput = {
    titulo: string
    descripcion: string
    comentarios?: comentariosCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenCreateNestedManyWithoutPublicacionesInput
    categorias: categoriasCreateNestedOneWithoutPublicacionesInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateWithoutPublicacionesguardadasInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
    comentarios?: comentariosUncheckedCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesCreateOrConnectWithoutPublicacionesguardadasInput = {
    where: publicacionesWhereUniqueInput
    create: XOR<publicacionesCreateWithoutPublicacionesguardadasInput, publicacionesUncheckedCreateWithoutPublicacionesguardadasInput>
  }

  export type usuarioCreateWithoutPublicacionesguardadasInput = {
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosCreateNestedManyWithoutUsuarioInput
    publicaciones?: publicacionesCreateNestedManyWithoutUsuarioInput
    tablero?: tableroCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPublicacionesguardadasInput = {
    idusuario?: number
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUsuarioInput
    publicaciones?: publicacionesUncheckedCreateNestedManyWithoutUsuarioInput
    tablero?: tableroUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPublicacionesguardadasInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPublicacionesguardadasInput, usuarioUncheckedCreateWithoutPublicacionesguardadasInput>
  }

  export type publicacionesUpsertWithoutPublicacionesguardadasInput = {
    update: XOR<publicacionesUpdateWithoutPublicacionesguardadasInput, publicacionesUncheckedUpdateWithoutPublicacionesguardadasInput>
    create: XOR<publicacionesCreateWithoutPublicacionesguardadasInput, publicacionesUncheckedCreateWithoutPublicacionesguardadasInput>
  }

  export type publicacionesUpdateWithoutPublicacionesguardadasInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    comentarios?: comentariosUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUpdateManyWithoutPublicacionesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutPublicacionesNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateWithoutPublicacionesguardadasInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    comentarios?: comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type usuarioUpsertWithoutPublicacionesguardadasInput = {
    update: XOR<usuarioUpdateWithoutPublicacionesguardadasInput, usuarioUncheckedUpdateWithoutPublicacionesguardadasInput>
    create: XOR<usuarioCreateWithoutPublicacionesguardadasInput, usuarioUncheckedCreateWithoutPublicacionesguardadasInput>
  }

  export type usuarioUpdateWithoutPublicacionesguardadasInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUpdateManyWithoutUsuarioNestedInput
    publicaciones?: publicacionesUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPublicacionesguardadasInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUncheckedUpdateManyWithoutUsuarioNestedInput
    publicaciones?: publicacionesUncheckedUpdateManyWithoutUsuarioNestedInput
    tablero?: tableroUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type tableroCreateWithoutPublicacionestableroInput = {
    nombre: string
    privacidad: number
    imagen?: Buffer | null
    usuario: usuarioCreateNestedOneWithoutTableroInput
  }

  export type tableroUncheckedCreateWithoutPublicacionestableroInput = {
    idtablero?: number
    nombre: string
    privacidad: number
    idusuario: number
    imagen?: Buffer | null
  }

  export type tableroCreateOrConnectWithoutPublicacionestableroInput = {
    where: tableroWhereUniqueInput
    create: XOR<tableroCreateWithoutPublicacionestableroInput, tableroUncheckedCreateWithoutPublicacionestableroInput>
  }

  export type publicacionesCreateWithoutPublicacionestableroInput = {
    titulo: string
    descripcion: string
    comentarios?: comentariosCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenCreateNestedManyWithoutPublicacionesInput
    categorias: categoriasCreateNestedOneWithoutPublicacionesInput
    usuario: usuarioCreateNestedOneWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateWithoutPublicacionestableroInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    idusuario: number
    comentarios?: comentariosUncheckedCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesCreateOrConnectWithoutPublicacionestableroInput = {
    where: publicacionesWhereUniqueInput
    create: XOR<publicacionesCreateWithoutPublicacionestableroInput, publicacionesUncheckedCreateWithoutPublicacionestableroInput>
  }

  export type tableroUpsertWithoutPublicacionestableroInput = {
    update: XOR<tableroUpdateWithoutPublicacionestableroInput, tableroUncheckedUpdateWithoutPublicacionestableroInput>
    create: XOR<tableroCreateWithoutPublicacionestableroInput, tableroUncheckedCreateWithoutPublicacionestableroInput>
  }

  export type tableroUpdateWithoutPublicacionestableroInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    usuario?: usuarioUpdateOneRequiredWithoutTableroNestedInput
  }

  export type tableroUncheckedUpdateWithoutPublicacionestableroInput = {
    idtablero?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type publicacionesUpsertWithoutPublicacionestableroInput = {
    update: XOR<publicacionesUpdateWithoutPublicacionestableroInput, publicacionesUncheckedUpdateWithoutPublicacionestableroInput>
    create: XOR<publicacionesCreateWithoutPublicacionestableroInput, publicacionesUncheckedCreateWithoutPublicacionestableroInput>
  }

  export type publicacionesUpdateWithoutPublicacionestableroInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    comentarios?: comentariosUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUpdateManyWithoutPublicacionesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutPublicacionesNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateWithoutPublicacionestableroInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    comentarios?: comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionestableroCreateWithoutTableroInput = {
    publicaciones: publicacionesCreateNestedOneWithoutPublicacionestableroInput
  }

  export type publicacionestableroUncheckedCreateWithoutTableroInput = {
    idpublicacionestablero?: number
    idpublicacion: number
  }

  export type publicacionestableroCreateOrConnectWithoutTableroInput = {
    where: publicacionestableroWhereUniqueInput
    create: XOR<publicacionestableroCreateWithoutTableroInput, publicacionestableroUncheckedCreateWithoutTableroInput>
  }

  export type publicacionestableroCreateManyTableroInputEnvelope = {
    data: Enumerable<publicacionestableroCreateManyTableroInput>
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutTableroInput = {
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosCreateNestedManyWithoutUsuarioInput
    publicaciones?: publicacionesCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutTableroInput = {
    idusuario?: number
    username: string
    email: string
    userpassword?: string | null
    fotoperfil?: string | null
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUsuarioInput
    publicaciones?: publicacionesUncheckedCreateNestedManyWithoutUsuarioInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutTableroInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutTableroInput, usuarioUncheckedCreateWithoutTableroInput>
  }

  export type publicacionestableroUpsertWithWhereUniqueWithoutTableroInput = {
    where: publicacionestableroWhereUniqueInput
    update: XOR<publicacionestableroUpdateWithoutTableroInput, publicacionestableroUncheckedUpdateWithoutTableroInput>
    create: XOR<publicacionestableroCreateWithoutTableroInput, publicacionestableroUncheckedCreateWithoutTableroInput>
  }

  export type publicacionestableroUpdateWithWhereUniqueWithoutTableroInput = {
    where: publicacionestableroWhereUniqueInput
    data: XOR<publicacionestableroUpdateWithoutTableroInput, publicacionestableroUncheckedUpdateWithoutTableroInput>
  }

  export type publicacionestableroUpdateManyWithWhereWithoutTableroInput = {
    where: publicacionestableroScalarWhereInput
    data: XOR<publicacionestableroUpdateManyMutationInput, publicacionestableroUncheckedUpdateManyWithoutPublicacionestableroInput>
  }

  export type usuarioUpsertWithoutTableroInput = {
    update: XOR<usuarioUpdateWithoutTableroInput, usuarioUncheckedUpdateWithoutTableroInput>
    create: XOR<usuarioCreateWithoutTableroInput, usuarioUncheckedCreateWithoutTableroInput>
  }

  export type usuarioUpdateWithoutTableroInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUpdateManyWithoutUsuarioNestedInput
    publicaciones?: publicacionesUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutTableroInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userpassword?: NullableStringFieldUpdateOperationsInput | string | null
    fotoperfil?: NullableStringFieldUpdateOperationsInput | string | null
    comentarios?: comentariosUncheckedUpdateManyWithoutUsuarioNestedInput
    publicaciones?: publicacionesUncheckedUpdateManyWithoutUsuarioNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type comentariosCreateWithoutUsuarioInput = {
    descripcion: string
    fecha: Date | string
    publicaciones: publicacionesCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateWithoutUsuarioInput = {
    idcomentarios?: number
    descripcion: string
    fecha: Date | string
    idpublicacion: number
  }

  export type comentariosCreateOrConnectWithoutUsuarioInput = {
    where: comentariosWhereUniqueInput
    create: XOR<comentariosCreateWithoutUsuarioInput, comentariosUncheckedCreateWithoutUsuarioInput>
  }

  export type comentariosCreateManyUsuarioInputEnvelope = {
    data: Enumerable<comentariosCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type publicacionesCreateWithoutUsuarioInput = {
    titulo: string
    descripcion: string
    comentarios?: comentariosCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenCreateNestedManyWithoutPublicacionesInput
    categorias: categoriasCreateNestedOneWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesUncheckedCreateWithoutUsuarioInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
    comentarios?: comentariosUncheckedCreateNestedManyWithoutPublicacionesInput
    imagen?: imagenUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionesguardadas?: publicacionesguardadasUncheckedCreateNestedManyWithoutPublicacionesInput
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutPublicacionesInput
  }

  export type publicacionesCreateOrConnectWithoutUsuarioInput = {
    where: publicacionesWhereUniqueInput
    create: XOR<publicacionesCreateWithoutUsuarioInput, publicacionesUncheckedCreateWithoutUsuarioInput>
  }

  export type publicacionesCreateManyUsuarioInputEnvelope = {
    data: Enumerable<publicacionesCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type publicacionesguardadasCreateWithoutUsuarioInput = {
    publicaciones: publicacionesCreateNestedOneWithoutPublicacionesguardadasInput
  }

  export type publicacionesguardadasUncheckedCreateWithoutUsuarioInput = {
    idpublicacionesguardadas?: number
    idpublicacion: number
  }

  export type publicacionesguardadasCreateOrConnectWithoutUsuarioInput = {
    where: publicacionesguardadasWhereUniqueInput
    create: XOR<publicacionesguardadasCreateWithoutUsuarioInput, publicacionesguardadasUncheckedCreateWithoutUsuarioInput>
  }

  export type publicacionesguardadasCreateManyUsuarioInputEnvelope = {
    data: Enumerable<publicacionesguardadasCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type tableroCreateWithoutUsuarioInput = {
    nombre: string
    privacidad: number
    imagen?: Buffer | null
    publicacionestablero?: publicacionestableroCreateNestedManyWithoutTableroInput
  }

  export type tableroUncheckedCreateWithoutUsuarioInput = {
    idtablero?: number
    nombre: string
    privacidad: number
    imagen?: Buffer | null
    publicacionestablero?: publicacionestableroUncheckedCreateNestedManyWithoutTableroInput
  }

  export type tableroCreateOrConnectWithoutUsuarioInput = {
    where: tableroWhereUniqueInput
    create: XOR<tableroCreateWithoutUsuarioInput, tableroUncheckedCreateWithoutUsuarioInput>
  }

  export type tableroCreateManyUsuarioInputEnvelope = {
    data: Enumerable<tableroCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type comentariosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: comentariosWhereUniqueInput
    update: XOR<comentariosUpdateWithoutUsuarioInput, comentariosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<comentariosCreateWithoutUsuarioInput, comentariosUncheckedCreateWithoutUsuarioInput>
  }

  export type comentariosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: comentariosWhereUniqueInput
    data: XOR<comentariosUpdateWithoutUsuarioInput, comentariosUncheckedUpdateWithoutUsuarioInput>
  }

  export type comentariosUpdateManyWithWhereWithoutUsuarioInput = {
    where: comentariosScalarWhereInput
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyWithoutComentariosInput>
  }

  export type publicacionesUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: publicacionesWhereUniqueInput
    update: XOR<publicacionesUpdateWithoutUsuarioInput, publicacionesUncheckedUpdateWithoutUsuarioInput>
    create: XOR<publicacionesCreateWithoutUsuarioInput, publicacionesUncheckedCreateWithoutUsuarioInput>
  }

  export type publicacionesUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: publicacionesWhereUniqueInput
    data: XOR<publicacionesUpdateWithoutUsuarioInput, publicacionesUncheckedUpdateWithoutUsuarioInput>
  }

  export type publicacionesUpdateManyWithWhereWithoutUsuarioInput = {
    where: publicacionesScalarWhereInput
    data: XOR<publicacionesUpdateManyMutationInput, publicacionesUncheckedUpdateManyWithoutPublicacionesInput>
  }

  export type publicacionesguardadasUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: publicacionesguardadasWhereUniqueInput
    update: XOR<publicacionesguardadasUpdateWithoutUsuarioInput, publicacionesguardadasUncheckedUpdateWithoutUsuarioInput>
    create: XOR<publicacionesguardadasCreateWithoutUsuarioInput, publicacionesguardadasUncheckedCreateWithoutUsuarioInput>
  }

  export type publicacionesguardadasUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: publicacionesguardadasWhereUniqueInput
    data: XOR<publicacionesguardadasUpdateWithoutUsuarioInput, publicacionesguardadasUncheckedUpdateWithoutUsuarioInput>
  }

  export type publicacionesguardadasUpdateManyWithWhereWithoutUsuarioInput = {
    where: publicacionesguardadasScalarWhereInput
    data: XOR<publicacionesguardadasUpdateManyMutationInput, publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesguardadasInput>
  }

  export type tableroUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: tableroWhereUniqueInput
    update: XOR<tableroUpdateWithoutUsuarioInput, tableroUncheckedUpdateWithoutUsuarioInput>
    create: XOR<tableroCreateWithoutUsuarioInput, tableroUncheckedCreateWithoutUsuarioInput>
  }

  export type tableroUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: tableroWhereUniqueInput
    data: XOR<tableroUpdateWithoutUsuarioInput, tableroUncheckedUpdateWithoutUsuarioInput>
  }

  export type tableroUpdateManyWithWhereWithoutUsuarioInput = {
    where: tableroScalarWhereInput
    data: XOR<tableroUpdateManyMutationInput, tableroUncheckedUpdateManyWithoutTableroInput>
  }

  export type tableroScalarWhereInput = {
    AND?: Enumerable<tableroScalarWhereInput>
    OR?: Enumerable<tableroScalarWhereInput>
    NOT?: Enumerable<tableroScalarWhereInput>
    idtablero?: IntFilter | number
    nombre?: StringFilter | string
    privacidad?: IntFilter | number
    idusuario?: IntFilter | number
    imagen?: BytesNullableFilter | Buffer | null
  }

  export type publicacionesCreateManyCategoriasInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idusuario: number
  }

  export type publicacionesUpdateWithoutCategoriasInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    comentarios?: comentariosUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUpdateManyWithoutPublicacionesNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateWithoutCategoriasInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idusuario?: IntFieldUpdateOperationsInput | number
    comentarios?: comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateManyWithoutPublicacionesInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type comentariosCreateManyPublicacionesInput = {
    idcomentarios?: number
    descripcion: string
    fecha: Date | string
    idusuario: number
  }

  export type imagenCreateManyPublicacionesInput = {
    idimagen?: number
    imagen: Buffer
  }

  export type publicacionesguardadasCreateManyPublicacionesInput = {
    idpublicacionesguardadas?: number
    idusuario: number
  }

  export type publicacionestableroCreateManyPublicacionesInput = {
    idpublicacionestablero?: number
    idtablero: number
  }

  export type comentariosUpdateWithoutPublicacionesInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateWithoutPublicacionesInput = {
    idcomentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type comentariosUncheckedUpdateManyWithoutComentariosInput = {
    idcomentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type imagenUpdateWithoutPublicacionesInput = {
    imagen?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type imagenUncheckedUpdateWithoutPublicacionesInput = {
    idimagen?: IntFieldUpdateOperationsInput | number
    imagen?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type imagenUncheckedUpdateManyWithoutImagenInput = {
    idimagen?: IntFieldUpdateOperationsInput | number
    imagen?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type publicacionesguardadasUpdateWithoutPublicacionesInput = {
    usuario?: usuarioUpdateOneRequiredWithoutPublicacionesguardadasNestedInput
  }

  export type publicacionesguardadasUncheckedUpdateWithoutPublicacionesInput = {
    idpublicacionesguardadas?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesguardadasInput = {
    idpublicacionesguardadas?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionestableroUpdateWithoutPublicacionesInput = {
    tablero?: tableroUpdateOneRequiredWithoutPublicacionestableroNestedInput
  }

  export type publicacionestableroUncheckedUpdateWithoutPublicacionesInput = {
    idpublicacionestablero?: IntFieldUpdateOperationsInput | number
    idtablero?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionestableroUncheckedUpdateManyWithoutPublicacionestableroInput = {
    idpublicacionestablero?: IntFieldUpdateOperationsInput | number
    idtablero?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionestableroCreateManyTableroInput = {
    idpublicacionestablero?: number
    idpublicacion: number
  }

  export type publicacionestableroUpdateWithoutTableroInput = {
    publicaciones?: publicacionesUpdateOneRequiredWithoutPublicacionestableroNestedInput
  }

  export type publicacionestableroUncheckedUpdateWithoutTableroInput = {
    idpublicacionestablero?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type comentariosCreateManyUsuarioInput = {
    idcomentarios?: number
    descripcion: string
    fecha: Date | string
    idpublicacion: number
  }

  export type publicacionesCreateManyUsuarioInput = {
    idpublicaciones?: number
    titulo: string
    descripcion: string
    idcategoria: number
  }

  export type publicacionesguardadasCreateManyUsuarioInput = {
    idpublicacionesguardadas?: number
    idpublicacion: number
  }

  export type tableroCreateManyUsuarioInput = {
    idtablero?: number
    nombre: string
    privacidad: number
    imagen?: Buffer | null
  }

  export type comentariosUpdateWithoutUsuarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    publicaciones?: publicacionesUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateWithoutUsuarioInput = {
    idcomentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type publicacionesUpdateWithoutUsuarioInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    comentarios?: comentariosUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUpdateManyWithoutPublicacionesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesUncheckedUpdateWithoutUsuarioInput = {
    idpublicaciones?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    idcategoria?: IntFieldUpdateOperationsInput | number
    comentarios?: comentariosUncheckedUpdateManyWithoutPublicacionesNestedInput
    imagen?: imagenUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionesguardadas?: publicacionesguardadasUncheckedUpdateManyWithoutPublicacionesNestedInput
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutPublicacionesNestedInput
  }

  export type publicacionesguardadasUpdateWithoutUsuarioInput = {
    publicaciones?: publicacionesUpdateOneRequiredWithoutPublicacionesguardadasNestedInput
  }

  export type publicacionesguardadasUncheckedUpdateWithoutUsuarioInput = {
    idpublicacionesguardadas?: IntFieldUpdateOperationsInput | number
    idpublicacion?: IntFieldUpdateOperationsInput | number
  }

  export type tableroUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    publicacionestablero?: publicacionestableroUpdateManyWithoutTableroNestedInput
  }

  export type tableroUncheckedUpdateWithoutUsuarioInput = {
    idtablero?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    publicacionestablero?: publicacionestableroUncheckedUpdateManyWithoutTableroNestedInput
  }

  export type tableroUncheckedUpdateManyWithoutTableroInput = {
    idtablero?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    privacidad?: IntFieldUpdateOperationsInput | number
    imagen?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}